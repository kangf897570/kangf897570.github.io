<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 爱上口袋的天空</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/image1.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">爱上口袋的天空</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['欢迎来到爱上口袋的天空的博客', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_1.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/vultr.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-ES之词库的动态添加"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/18/ES%E4%B9%8B%E8%AF%8D%E5%BA%93%E7%9A%84%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0/"
    >ES之词库的动态添加</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/07/18/ES%E4%B9%8B%E8%AF%8D%E5%BA%93%E7%9A%84%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0/" class="article-date">
  <time datetime="2021-07-18T14:21:56.455Z" itemprop="datePublished">2021-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Elasticsearch/">Elasticsearch</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>title: ES之词库的动态添加<br>categories:</p>
<ul>
<li>elasticsearch</li>
</ul>
<p>—### 1、环境准备</p>
<blockquote>
<p> 1）安装nginx1.18.0<br> 2)  安装好ES7.8.1和kibana7.8.1（提前准备好） </p>
</blockquote>
<h3 id="2、安装nginx"><a href="#2、安装nginx" class="headerlink" title="2、安装nginx"></a>2、安装nginx</h3><blockquote>
<p> 2.1）拉取nginx1.18.0镜像<br>         docker pull nginx:1.18.0<br> 2.2）创建挂载容器里面的界面的访问<br>          mkdir -p /mydata/nignx/html<br> 2.3）在/mydata/nignx/html/中创建hotwords.txt<br>          <img alt="" height="208" src="https://img-blog.csdnimg.cn/20210704142127275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="464"><br> 2.4）docker命令启动nginx<br>          docker run -itd -p 80:80 -v /mydata/nignx/html:/usr/share/nginx/html nginx:1.18.0<br> <img alt="" height="156" src="https://img-blog.csdnimg.cn/20210704142706539.png" width="1200"><br> 2.5) 浏览器访问：<br>     <img alt="" height="131" src="https://img-blog.csdnimg.cn/20210704142903713.png" width="649"> </p>
</blockquote>
<h3 id="3、开始配置es"><a href="#3、开始配置es" class="headerlink" title="3、开始配置es"></a>3、开始配置es</h3><blockquote>
<p> 3.1) 进入/opt/es781/elasticsearch-7.8.1/plugins/ik/config目录下修改IKAnalyzer.cfg.xml<br> <img alt="" height="363" src="https://img-blog.csdnimg.cn/20210704143225821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="925"><br> 3.2）重启es<br> 3.3）使用kibana查看<br>      <img alt="" height="136" src="https://img-blog.csdnimg.cn/20210704143626716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="578"><br> 3.4）测试一个单词“就是我”<br>       <img alt="" height="190" src="https://img-blog.csdnimg.cn/20210704143741562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="591"><br>      我们在nginx的hotwords.txt中添加这个单词<br>        <img alt="" height="130" src="https://img-blog.csdnimg.cn/20210704143923740.png" width="506"><br> 不重启es直接查询：<br> <img alt="" height="280" src="https://img-blog.csdnimg.cn/2021070414394629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1053"> </p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-ELK知识点学习"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/18/ELK%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0/"
    >ELK知识点学习</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/07/18/ELK%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-07-18T14:21:56.453Z" itemprop="datePublished">2021-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Elasticsearch/">Elasticsearch</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>title: ELK知识点学习<br>categories:</p>
<ul>
<li>elasticsearch</li>
</ul>
<p>—title: ELK知识点学习<br>categories:</p>
<ul>
<li>elasticsearch</li>
</ul>
<p>—1. </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Elasticsearch之自动补全案例实战"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/18/Elasticsearch%E4%B9%8B%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/"
    >Elasticsearch之自动补全案例实战</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/07/18/Elasticsearch%E4%B9%8B%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/" class="article-date">
  <time datetime="2021-07-18T14:21:56.451Z" itemprop="datePublished">2021-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Elasticsearch/">Elasticsearch</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>title: Elasticsearch之自动补全案例实战<br>categories:</p>
<ul>
<li>elasticsearch</li>
</ul>
<p>—### 1、案例需求：</p>
<blockquote>
<p> 通过拼音以及汉字筛选对应的明星！ </p>
</blockquote>
<h3 id="2、设置分词器以及mapping"><a href="#2、设置分词器以及mapping" class="headerlink" title="2、设置分词器以及mapping"></a>2、设置分词器以及mapping</h3><blockquote>
 <pre><code class="language-javascript">PUT starts
&#123;
  "settings": &#123;
    "analysis": &#123;
      "analyzer": &#123;
        "start_name_analyzer":&#123;
          "char_filter":["html_strip"],
          "tokenizer":"keyword",
          "filter":"start_name_filter"
        &#125;
      &#125;,
      "filter": &#123;
        "start_name_filter":&#123;
          "type":"pinyin",
          "keep_full_pinyin":false,
          "keep_joined_full_pinyin":true,
          "keep_original": true
        &#125;
      &#125;
    &#125;
  &#125;,
  "mappings": &#123;
    "properties": &#123;
      "name":&#123;
        "type": "completion",
        "analyzer": "start_name_analyzer",
        "search_analyzer": "keyword"
      &#125;
    &#125;
  &#125;
&#125;</code></pre> 
 <img alt="" height="808" src="https://img-blog.csdnimg.cn/20210704163948950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> 
</blockquote>
<h3 id="3、批量插入数据"><a href="#3、批量插入数据" class="headerlink" title="3、批量插入数据"></a>3、批量插入数据</h3><blockquote>
 <pre><code class="language-javascript">PUT starts/_bulk
&#123;"index":&#123;&#125;&#125;
&#123;"name":"张学友"&#125;
&#123;"index":&#123;&#125;&#125;
&#123;"name":"刘德华"&#125;
&#123;"index":&#123;&#125;&#125;
&#123;"name":"柳岩"&#125;
&#123;"index":&#123;&#125;&#125;
&#123;"name":"李易峰"&#125;
&#123;"index":&#123;&#125;&#125;
&#123;"name":"黄晓明"&#125;
&#123;"index":&#123;&#125;&#125;
&#123;"name":"刘青云"&#125;
&#123;"index":&#123;&#125;&#125;
&#123;"name":"易中天"&#125;
&#123;"index":&#123;&#125;&#125;
&#123;"name":"李小璐"&#125;
&#123;"index":&#123;&#125;&#125;
&#123;"name":"黄家驹"&#125;
&#123;"index":&#123;&#125;&#125;
&#123;"name":"李思思"&#125;
&#123;"index":&#123;&#125;&#125;
&#123;"name":"庄媛媛"&#125;
&#123;"index":&#123;&#125;&#125;
&#123;"name":"刘亦菲"&#125;</code></pre> 
 <img alt="" height="688" src="https://img-blog.csdnimg.cn/20210704164406424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> 
</blockquote>
<h3 id="4、在kibana上测试一下效果"><a href="#4、在kibana上测试一下效果" class="headerlink" title="4、在kibana上测试一下效果"></a>4、在kibana上测试一下效果</h3><blockquote>
 <pre><code class="language-java">GET starts/_search
&#123;
  "_source": false,
  "suggest": &#123;
    "start_name_suggest": &#123;
      "prefix":"柳",
      "completion":&#123;
        "field":"name",
        "size": 10,
        "skip_duplicates": true
      &#125;
    &#125;
  &#125;
&#125;</code></pre> 
 <img alt="" height="835" src="https://img-blog.csdnimg.cn/20210704164750795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> 
 <img alt="" height="949" src="https://img-blog.csdnimg.cn/20210704164822955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> 
 <img alt="" height="862" src="https://img-blog.csdnimg.cn/20210704164910346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> 
 <img alt="" height="970" src="https://img-blog.csdnimg.cn/2021070416502437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> 
</blockquote>
<h3 id="5、在java服务端实现上面测试的自动补全案例"><a href="#5、在java服务端实现上面测试的自动补全案例" class="headerlink" title="5、在java服务端实现上面测试的自动补全案例"></a>5、在java服务端实现上面测试的自动补全案例</h3><blockquote>
<p> 5.1、Springboot整合ES7.8.1已经提前整合了<br> 5.2、创建controller类<br> <pre><code class="language-java">package com.kgf.es.controller;</p>
</blockquote>
<p>import com.alibaba.fastjson.JSONArray;<br>import com.alibaba.fastjson.JSONObject;<br>import org.apache.http.util.EntityUtils;<br>import org.elasticsearch.client.Request;<br>import org.elasticsearch.client.Response;<br>import org.elasticsearch.client.RestHighLevelClient;<br>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RequestMapping;<br>import org.springframework.web.bind.annotation.RestController;</p>
<p>import javax.annotation.Resource;<br>import java.io.IOException;<br>import java.util.ArrayList;<br>import java.util.List;</p>
<p>@RequestMapping(“start”)<br>@RestController<br>public class StartController &#123;</p>
<pre><code>@Resource
private RestHighLevelClient restHighLevelClient;

@GetMapping(&quot;autoComplete&quot;)
public Object autoComplete(String term) throws IOException &#123;
    Request request = new Request(&quot;GET&quot;, &quot;starts/_search&quot;);
    request.setJsonEntity(String.format(&quot;&#123;&quot; +
            &quot;  \&quot;_source\&quot;: false,&quot; +
            &quot;  \&quot;suggest\&quot;: &#123;&quot; +
            &quot;    \&quot;start_name_suggest\&quot;: &#123;&quot; +
            &quot;      \&quot;prefix\&quot;:\&quot;%s\&quot;,&quot; +
            &quot;      \&quot;completion\&quot;:&#123;&quot; +
            &quot;        \&quot;field\&quot;:\&quot;name\&quot;,&quot; +
            &quot;        \&quot;size\&quot;: 10,&quot; +
            &quot;        \&quot;skip_duplicates\&quot;: true&quot; +
            &quot;      &#125;&quot; +
            &quot;    &#125;&quot; +
            &quot;  &#125;&quot; +
            &quot;&#125;&quot;,term));
    Response response = restHighLevelClient.getLowLevelClient().performRequest(request);
    String json = EntityUtils.toString(response.getEntity());
    JSONObject jsonObject = JSONObject.parseObject(json);
    JSONArray suggests = jsonObject.getJSONObject(&quot;suggest&quot;).getJSONArray(&quot;start_name_suggest&quot;);
    JSONArray options = suggests.getJSONObject(0).getJSONArray(&quot;options&quot;);
    List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    for (int i = 0; i &amp;lt; options.size(); i++) &#123;
        JSONObject object = options.getJSONObject(i);
        list.add(object.getString(&quot;text&quot;));
    &#125;
    return list;
&#125;
</code></pre>
<p>}<br></code></pre> </p>
<h3 id="6、访问测试效果"><a href="#6、访问测试效果" class="headerlink" title="6、访问测试效果"></a>6、访问测试效果</h3><blockquote>
 <img alt="" height="290" src="https://img-blog.csdnimg.cn/20210704181240367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="807"> 
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Elasticsearch之新闻案例实战"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/18/Elasticsearch%E4%B9%8B%E6%96%B0%E9%97%BB%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/"
    >Elasticsearch之新闻案例实战</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/07/18/Elasticsearch%E4%B9%8B%E6%96%B0%E9%97%BB%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/" class="article-date">
  <time datetime="2021-07-18T14:21:56.449Z" itemprop="datePublished">2021-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Elasticsearch/">Elasticsearch</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>title: Elasticsearch之新闻案例实战<br>categories:</p>
<ul>
<li>elasticsearch</li>
</ul>
<p>—### 1、创建数据库表且预置数据</p>
<blockquote>
<p> 1.1、表结构如下<br> <pre><code class="language-sql">DROP TABLE IF EXISTS <code>news</code>;<br>CREATE TABLE <code>news</code> (<br>    <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>    <code>title</code> varchar(255) NOT NULL comment '主题',<br>    <code>url</code> varchar(255) DEFAULT NULL comment '连接',<br>    <code>content</code> text comment '内容',<br>    <code>tags</code> varchar(1000) DEFAULT NULL comment '搜索的关键字',<br>    PRIMARY KEY (<code>id</code>) USING BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=92 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;</code></pre><br> 1.2、数据如下<br> <img alt="" height="629" src="https://img-blog.csdnimg.cn/20210704215709241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> </p>
</blockquote>
<h3 id="2、定义分词器以及属性类型"><a href="#2、定义分词器以及属性类型" class="headerlink" title="2、定义分词器以及属性类型"></a>2、定义分词器以及属性类型</h3><blockquote>
 <pre><code class="language-javascript">PUT news
&#123;
  "settings": &#123;
    "analysis": &#123;
      "analyzer": &#123;
        "news_tags_analyzer": &#123;
          "char_filter": ["html_strip"],
          "tokenizer": "keyword",
          "filter": "news_tags_filter"
        &#125;
      &#125;,
      "filter": &#123;
        "news_tags_filter": &#123;
          "type": "pinyin",
          "keep_full_pinyin": true,
          "keep_joined_full_pinyin": true,
          "keep_original": true
        &#125;
      &#125;
    &#125;
  &#125;,
  "mappings": &#123;
    "properties": &#123;
      "id": &#123;
        "type": "long"
      &#125;,
      "title": &#123;
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      &#125;,
      "content": &#123;
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      &#125;,
      "url": &#123;
        "type": "keyword"
      &#125;,
      "tags": &#123;
        "type": "completion",
        "analyzer": "news_tags_analyzer",
        "search_analyzer": "keyword"
      &#125;
    &#125;
  &#125;
&#125;</code></pre> 
<p>  <img alt="" height="590" src="https://img-blog.csdnimg.cn/20210704221658848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1185"> </p>
</blockquote>
<h3 id="3、将mysql数据导入es"><a href="#3、将mysql数据导入es" class="headerlink" title="3、将mysql数据导入es"></a>3、将mysql数据导入es</h3><blockquote>
<p> 2.1、创建logstash-mysql-news.conf文件<br> <pre><code class="language-html">#input表示将数据读取到logstash中<br>input &#123;<br>  jdbc &#123;<br>    jdbc_driver_library =&gt; "/opt/es781/mysql/mysql-connector-java-5.1.49.jar"<br>    jdbc_driver_class =&gt; "com.mysql.jdbc.Driver"<br>    jdbc_connection_string =&gt; "jdbc:mysql://192.168.1.13:3306/oss?userUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimeZone=UTC"<br>    jdbc_user =&gt; "root"<br>    jdbc_password =&gt; "897570"<br>    #表示是否分页<br>    jdbc_paging_enabled =&gt; "true"<br>    #表示每页的数量<br>    jdbc_page_size =&gt; "20"<br>    #查询语句<br>    statement =&gt; "SELECT * FROM news where tags is not null"<br>  &#125;<br>&#125;<br>#这个filter表示对数据进行过滤<br>filter &#123;<br>  mutate &#123;<br>    #根据逗号切割关键字<br>    split =&gt; &#123; "tags" =&gt; ","&#125;<br>  &#125;<br>  #将下面两个字段过滤掉，logstash会自动帮我们加这两个属性，我们不需要，直接去掉<br>  mutate &#123;<br>    remove_field =&gt; ["@timestamp","@version"]<br>  &#125;<br>&#125;<br>#将logstash中的数据输出到es中<br>output &#123;<br>  elasticsearch &#123;<br>    document_id =&gt; "%&#123;id&#125;"<br>    document_type =&gt; "_doc"<br>    index =&gt; "news"<br>    hosts =&gt; ["<a href="http://192.168.56.20:9200&quot;]">http://192.168.56.20:9200&quot;]</a><br>  &#125;<br>  stdout&#123;<br>    codec =&gt; rubydebug<br>  &#125;<br>&#125;<br></code></pre><br> 2.2、将上面需要的mysql jar包上传到Linux服务器上<br> <img alt="" height="223" src="https://img-blog.csdnimg.cn/20210704220031533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="804"><br> 2.3、将logstash-mysql-news.conf文件上传到/opt/es781/logstash-7.8.1/目录下<br> <img alt="" height="589" src="https://img-blog.csdnimg.cn/20210704220333418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="776"><br> 2.4、在/opt/es781/logstash-7.8.1/目录下执行下面的命令将数据从mysql中导入es,<br>      命令：bin/logstash -f /opt/es781/logstash-7.8.1/logstash-mysql-news.conf      <img alt="" height="903" src="https://img-blog.csdnimg.cn/20210704220730172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1089"><br> 2.5、在kibana上查询news索引是否成功导入数据<br> <img alt="" height="936" src="https://img-blog.csdnimg.cn/20210704220858401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> </p>
</blockquote>
<h3 id="4、根据需求编写kibana脚本"><a href="#4、根据需求编写kibana脚本" class="headerlink" title="4、根据需求编写kibana脚本"></a>4、根据需求编写kibana脚本</h3><blockquote>
<p> 4.1、自动补全语句<br> <pre><code class="language-javascript">GET news/_search<br>&#123;<br>  "_source": false,<br>  "suggest": &#123;<br>    "news_tags_suggest": &#123;<br>      "prefix": "zh",<br>      "completion":&#123;<br>        "field":"tags",<br>        "size": 10,<br>        "skip_duplicates": true<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;</code></pre><br> <img alt="" height="464" src="https://img-blog.csdnimg.cn/20210704222803907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"><br> 4.2、内容搜索<br> <pre><code class="language-javascript">GET news/_search<br>&#123;<br>  "_source": false,<br>  "query": &#123;<br>    "multi_match": &#123;<br>      "query": "中国",<br>      "fields": ["title","content"]<br>    &#125;<br>  &#125;,<br>  "highlight": &#123;<br>    "pre_tags": "&lt;span class='highLight'&gt;",<br>    "post_tags": "&lt;/span&gt;",<br>    "fields": &#123;<br>      "title": &#123;&#125;,<br>      "content": &#123;&#125;<br>    &#125;<br>  &#125;<br>&#125;</code></pre><br> <img alt="" height="766" src="https://img-blog.csdnimg.cn/20210704222727872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> </p>
</blockquote>
<h3 id="5、在java中使用代码实现上面两个搜索"><a href="#5、在java中使用代码实现上面两个搜索" class="headerlink" title="5、在java中使用代码实现上面两个搜索"></a>5、在java中使用代码实现上面两个搜索</h3><blockquote>
<p> 5.1、创建news实体类<br> <pre><code class="language-java">package com.kgf.es.model;</p>
</blockquote>
<p>import lombok.AllArgsConstructor;<br>import lombok.Data;<br>import lombok.NoArgsConstructor;</p>
<p>@Data<br>@AllArgsConstructor<br>@NoArgsConstructor<br>public class News &#123;<br>    private Integer id;<br>    private String title;<br>    private String content;<br>    private String url;<br>&#125;<br></code></pre><br> 5.2、创建NewsController<br> <pre><code class="language-java">package com.kgf.es.controller;</p>
<p>import com.alibaba.fastjson.JSONArray;<br>import com.alibaba.fastjson.JSONObject;<br>import com.kgf.es.model.News;<br>import org.apache.http.util.EntityUtils;<br>import org.elasticsearch.client.Request;<br>import org.elasticsearch.client.Response;<br>import org.elasticsearch.client.RestHighLevelClient;<br>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RequestMapping;<br>import org.springframework.web.bind.annotation.RestController;</p>
<p>import javax.annotation.Resource;<br>import java.io.IOException;<br>import java.util.ArrayList;<br>import java.util.List;</p>
<p>@RestController<br>@RequestMapping(“/news”)<br>public class NewsController &#123;</p>
<pre><code>@Resource
private RestHighLevelClient restHighLevelClient;


@GetMapping(&quot;/tips&quot;)
public Object autoComplete(String term) throws IOException &#123;
    Request request = new Request(&quot;GET&quot;, &quot;news/_search&quot;);

    request.setJsonEntity(String.format(&quot;&#123;&quot; +
            &quot;  \&quot;_source\&quot;: false, &quot; +
            &quot;  \&quot;suggest\&quot;: &#123;&quot; +
            &quot;    \&quot;news_tags_suggest\&quot;: &#123;&quot; +
            &quot;      \&quot;prefix\&quot;: \&quot;%s\&quot;,&quot; +
            &quot;      \&quot;completion\&quot;: &#123;&quot; +
            &quot;        \&quot;field\&quot;: \&quot;tags\&quot;,&quot; +
            &quot;        \&quot;size\&quot;: 10,&quot; +
            &quot;        \&quot;skip_duplicates\&quot;: true&quot; +
            &quot;      &#125;&quot; +
            &quot;    &#125;&quot; +
            &quot;  &#125;&quot; +
            &quot;&#125;&quot;, term));

    Response response = restHighLevelClient.getLowLevelClient().performRequest(request);

    String jsonString = EntityUtils.toString(response.getEntity()); // &quot;&#123;\&quot;age\&quot;: 10&#125;&quot;  &#123;&quot;age&quot;: 10&#125;

    JSONObject jsonObject = JSONObject.parseObject(jsonString);

    JSONArray suggests = jsonObject.getJSONObject(&quot;suggest&quot;).getJSONArray(&quot;news_tags_suggest&quot;);

    JSONArray options = suggests.getJSONObject(0).getJSONArray(&quot;options&quot;);

    List&amp;lt;String&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();
    for(int i = 0; i &amp;lt; options.size(); i++) &#123;
        JSONObject opt = options.getJSONObject(i);
        results.add(opt.getString(&quot;text&quot;));
    &#125;

    return results;
&#125;

@GetMapping(&quot;/search&quot;)
public List&amp;lt;News&amp;gt; query(String text) throws Exception&#123;
    /**
     * 1.对于高亮的数据，ES是抽取的一个个片段，然后将这些片段设置到一个数组中。
     * 2.对于有些数据，可能title或者content中没有高亮的字眼，那么我们就需要取原始数据的 title 和 content.
     */
    Request request = new Request(&quot;GET&quot;, &quot;news/_search&quot;);
    request.setJsonEntity(String.format(&quot;&#123;&quot; +
            &quot;  \&quot;_source\&quot;: [\&quot;url\&quot;, \&quot;title\&quot;, \&quot;content\&quot;], &quot; +
            &quot;  \&quot;query\&quot;: &#123;&quot; +
            &quot;    \&quot;multi_match\&quot;: &#123;&quot; +
            &quot;      \&quot;query\&quot;: \&quot;%s\&quot;,&quot; +
            &quot;      \&quot;fields\&quot;: [\&quot;title\&quot;, \&quot;content\&quot;]&quot; +
            &quot;    &#125;&quot; +
            &quot;  &#125;,&quot; +
            &quot;  \&quot;highlight\&quot;: &#123;&quot; +
            &quot;    \&quot;pre_tags\&quot;: \&quot;&amp;lt;span class=&#39;highLight&#39;&amp;gt;\&quot;, &quot; +
            &quot;    \&quot;post_tags\&quot;: \&quot;&amp;lt;/span&amp;gt;\&quot;, &quot; +
            &quot;    \&quot;fields\&quot;: &#123;&quot; +
            &quot;      \&quot;title\&quot;: &#123;&#125;,&quot; +
            &quot;      \&quot;content\&quot;: &#123;&#125;&quot; +
            &quot;    &#125;&quot; +
            &quot;  &#125;&quot; +
            &quot;&#125;&quot;, text));

    Response response = restHighLevelClient.getLowLevelClient().performRequest(request);

    JSONObject jsonObject = JSONObject.parseObject(EntityUtils.toString(response.getEntity()));

    JSONArray hits = jsonObject.getJSONObject(&quot;hits&quot;).getJSONArray(&quot;hits&quot;);

    List&amp;lt;News&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();

    for (int i = 0; i &amp;lt; hits.size(); i++) &#123;
        News news = new News();
        JSONObject hit = hits.getJSONObject(i);
        JSONObject highLight = hit.getJSONObject(&quot;highlight&quot;);  //获取高亮的数据结果

        JSONObject _source = hit.getJSONObject(&quot;_source&quot;); //这个是原始的数据
        news.setUrl(_source.getString(&quot;url&quot;));  //设置url

        JSONArray highLightTitle = highLight.getJSONArray(&quot;title&quot;);  //获取高亮的 title 数组
        JSONArray highLightContent = highLight.getJSONArray(&quot;content&quot;);

        if(null != highLightTitle) &#123;
            StringBuffer highLightTitleStringBuffer = new StringBuffer();
            for (int j = 0; j &amp;lt; highLightTitle.size(); j++) &#123;
                String titleSegment = highLightTitle.getString(j);
                highLightTitleStringBuffer.append(titleSegment);
            &#125;
            news.setTitle(highLightTitleStringBuffer.toString());
        &#125;else &#123;  // 如果不存在高亮的数据，那么就取原始数据
            news.setTitle(_source.getString(&quot;title&quot;));
        &#125;

        if(null != highLightContent) &#123;
            StringBuffer highLightContentStringBuffer = new StringBuffer();
            for (int j = 0; j &amp;lt; highLightContent.size(); j++) &#123;
                String contentSegment = highLightContent.getString(j);
                highLightContentStringBuffer.append(contentSegment);
            &#125;
            news.setContent(highLightContentStringBuffer.toString());
        &#125;else &#123;  // 如果不存在高亮的数据，那么就取原始数据
            news.setContent(_source.getString(&quot;content&quot;));
        &#125;

        results.add(news);
    &#125;
    return results;
&#125;
</code></pre>
<p>}<br></code></pre> </p>
<h3 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h3><blockquote>
<p> 6.1、测试tips,完成对tags的关键字检索<br> <img alt="" height="726" src="https://img-blog.csdnimg.cn/20210704230043938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="757"><br> 6.2、测试内容检索<br> <img alt="" height="918" src="https://img-blog.csdnimg.cn/20210704230215251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> </p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Elasticsearch之Request Body查询"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/18/Elasticsearch%E4%B9%8BRequest%20Body%E6%9F%A5%E8%AF%A2/"
    >Elasticsearch之Request Body查询</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/07/18/Elasticsearch%E4%B9%8BRequest%20Body%E6%9F%A5%E8%AF%A2/" class="article-date">
  <time datetime="2021-07-18T14:21:56.446Z" itemprop="datePublished">2021-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Elasticsearch/">Elasticsearch</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>title: Elasticsearch之Request Body查询<br>categories:</p>
<ul>
<li>elasticsearch</li>
</ul>
<p>—### 1、term查询简介</p>
<blockquote>
<p> term是表达语义的最小单位，在搜索的时候基本都要使用到term。 term查询的种类有：Term Query、Range Query等。 在ES中，Term查询不会对输入进行分词处理，将输入作为一个整体，在倒排索引中查找准确的词项。 我们也可以使用 Constant Score 将查询转换为一个filter,避免算分，利用缓存，提高查询的效 率。 </p>
</blockquote>
<h3 id="2、term与terms"><a href="#2、term与terms" class="headerlink" title="2、term与terms"></a>2、term与terms</h3><blockquote>
<p> 查询电影名字中包含有 beautiful 这个单词的所有的电影，用于查询的单词不会进行分词的处理<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “term”: {<!-- -->             “title”: {<!-- -->                 “value”: “beautiful”             }         }     } }<br> 查询电影名字中包含有 beautiful 或者 mind 这两个单词的所有的电影，用于查询的单词不会进行 分词的处理<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “terms”: {<!-- -->             “title”: [                 “beautiful”,                 “mind”             ]         }     } } </p>
</blockquote>
<h3 id="3、range"><a href="#3、range" class="headerlink" title="3、range"></a>3、range</h3><blockquote>
<p> 查询上映在2016到2018年的所有的电影，再根据上映时间的倒序进行排序<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “range”: {<!-- -->             “year”: {<!-- -->                 “gte”: 2016,                 “lte”: 2018             }          }     },     “sort”: [         {<!-- -->             “year”: {<!-- -->                 “order”: “desc”             }         }     ] } </p>
</blockquote>
<h3 id="4、Constant-Score"><a href="#4、Constant-Score" class="headerlink" title="4、Constant Score"></a>4、Constant Score</h3><blockquote>
<p> 查询title中包含有beautiful的所有的电影，不进行相关性算分，查询的数据进行缓存，提高效率<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “constant_score”: {<!-- -->             “filter”: {<!-- -->                 “term”: {<!-- -->                     “title”: “beautiful”                 }             }         }     } } </p>
</blockquote>
<h3 id="5、全文查询"><a href="#5、全文查询" class="headerlink" title="5、全文查询"></a>5、全文查询</h3><blockquote>
<p> 全文查询的种类有: Match Query、Match Phrase Query、Query String Query等 索引和搜索的时候都会进行分词，在查询的时候，会对输入进行分词，然后每个词项会逐个到底层进行 查询，将最终的结果进行合并 </p>
</blockquote>
<h3 id="6、match"><a href="#6、match" class="headerlink" title="6、match"></a>6、match</h3><blockquote>
<p> 查询电影名字中包含有beautiful的所有电影，每页十条，取第二页的数据<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “match”: {<!-- -->             “title”: “beautiful”         }     },     “from”: 10,     “size”: 10 }<br> 查询电影名字中包含有 beautiful 或者 mind 的所有的数据，但是只查询title和id两个属性<br> GET movies/_search {<!-- -->     “_source”: [“title”, “id”],         “query”: {<!-- -->             “match”: {<!-- -->                 “title”: “beautiful mind”             }         } } </p>
</blockquote>
<h3 id="7、match-phrase"><a href="#7、match-phrase" class="headerlink" title="7、match_phrase"></a>7、match_phrase</h3><blockquote>
<p> 查询电影名字中包含有 “beautiful mind” 这个短语的所有的数据<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “match_phrase”: {<!-- -->             “title”: “beautiful mind”         }     } }<br> 注意：match_phrase和term区别<br> term是将传入的文本原封不动地（不分词）拿去查询。 match会对输入进行分词处理后再去查询，部分命中的结果也会按照评分由高到低显示出来。 match_phrase是按短语查询，只有存在这个短语的文档才会被显示出来。<br> 也就是说，term和match_phrase都可以用于精确匹配，而match用于模糊匹配。<br> 上面说的也不是很准确：<br> match_phrase总结如下： </p>
</blockquote>
<ul>
<li>match_phrase还是分词后去搜的- 目标文档需要包含分词后的所有词- 目标文档还要保持这些词的相对顺序和文档中的一致</li>
</ul>
<h3 id="8、multi-match"><a href="#8、multi-match" class="headerlink" title="8、multi_match"></a>8、multi_match</h3><blockquote>
<p> 查询 title 或 genre 中包含有 beautiful 或者 Adventure 的所有的数据<br> GET movies/_search     {<!-- -->     “query”: {<!-- -->         “multi_match”: {<!-- -->             “query”: “beautiful Adventure”,             “fields”: [“title”, “genre”]         }     } }   </p>
</blockquote>
<h3 id="9、match-all"><a href="#9、match-all" class="headerlink" title="9、match_all"></a>9、match_all</h3><blockquote>
<p> 查询所有的数据<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “match_all”: {}     } } </p>
</blockquote>
<h3 id="10、query-string"><a href="#10、query-string" class="headerlink" title="10、query_string"></a>10、query_string</h3><blockquote>
<p> 查询 title 中包含有 beautiful 和 mind 的所有的电影<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “query_string”: {<!-- -->             “default_field”: “title”,             “query”: “mind AND beautiful”         }     } } 或者<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “query_string”: {<!-- -->             “default_field”: “title”,             “query”: “mind beautiful”,             “default_operator”: “AND”         }     } }   </p>
</blockquote>
<h3 id="11、simple-query-string"><a href="#11、simple-query-string" class="headerlink" title="11、simple_query_string"></a>11、simple_query_string</h3><blockquote>
<p> simple_query_string 覆盖了很多其他查询的用法。<br> 查询 title 中包含有 beautiful 和 mind 的所有的电影<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “simple_query_string”: {<!-- -->             “query”: “beautiful + mind”,             “fields”: [“title”]         }     } }<br> 或者<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “simple_query_string”: {<!-- -->             “query”: “beautiful mind”,             “fields”: [“title”],             “default_operator”: “AND”         }     } }<br> 查询title中包含 “beautiful mind” 这个短语的所有的电影 (用法和match_phrase类似)<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “simple_query_string”: {<!-- -->             “query”: “&quot;beautiful mind&quot;“,             “fields”: [“title”]         }     } }<br> 查询title或genre中包含有 beautiful mind romance 这个三个单词的所有的电影 （与multi_match类似）<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “simple_query_string”: {<!-- -->             “query”: “beautiful mind Romance”,             “fields”: [“title”, “genre”]         }     } }<br> 查询title中包含 “beautiful mind” 或者 “Modern Romance” 这两个短语的所有的电影<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “simple_query_string”: {<!-- -->             “query”: “&quot;beautiful mind&quot; | &quot;Modern Romance&quot;“,             “fields”: [“title”]         }     } }<br> 查询title或者genre中包含有 beautiful + mind 这个两个词，或者Comedy + Romance + Musical + Drama + Children 这个五个词的所有的数据<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “simple_query_string”: {<!-- -->             “query”: “(beautiful + mind) | (Comedy + Romance + Musical + Drama + Children)”,             “fields”: [“title”,”genre”]         }     } }<br> 查询 title 中包含 beautiful 和 people 但是不包含 Animals 的所有的数据<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “simple_query_string”: {<!-- -->             “query”: “beautiful + people + -Animals”,             “fields”: [“title”]         }     } } </p>
</blockquote>
<h3 id="12、模糊搜索"><a href="#12、模糊搜索" class="headerlink" title="12、模糊搜索"></a>12、模糊搜索</h3><blockquote>
<p> 查询title中从第6个字母开始只要最多纠正一次，就与 neverendign 匹配的所有的数据<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “fuzzy”: {<!-- -->             “title”: {<!-- -->                 “value”: “neverendign”,                 “fuzziness”: 1,                 “prefix_length”: 5             }         }     } } </p>
</blockquote>
<h3 id="13、多条件查询"><a href="#13、多条件查询" class="headerlink" title="13、多条件查询"></a>13、多条件查询</h3><blockquote>
<p> 查询title中包含有beautiful或者mind单词，并且上映时间在2016<del>1018年的所有的电影<br> GET movies/_search {<!-- -->     “query”: {<!-- -->         “bool”: {<!-- -->             “must”: [                 {<!-- -->                     “simple_query_string”: {<!-- -->                         “query”: “beautiful mind”,                         “fields”: [“title”]                     }                 },                 {<!-- -->                     “range”: {<!-- -->                         “year”: {<!-- -->                             “gte”: 2016,                             “lte”: 2018                         }                     }                 }             ]         }     } }<br> 查询 title 中包含有 beautiful 这个单词，并且上映年份在2016</del>2018年间的所有电影，但是不 进行相关性的算分 </p>
</blockquote>
<h1 id="filter不会进行相关性的算分，并且会将查出来的结果进行缓存，效率上比-query-高-GET-movies-search-“query”-“bool”-“filter”-“term”-“title”-“beautiful”-“range”-“year”-“gte”-2016-“lte”-2018"><a href="#filter不会进行相关性的算分，并且会将查出来的结果进行缓存，效率上比-query-高-GET-movies-search-“query”-“bool”-“filter”-“term”-“title”-“beautiful”-“range”-“year”-“gte”-2016-“lte”-2018" class="headerlink" title="filter不会进行相关性的算分，并且会将查出来的结果进行缓存，效率上比 query 高 GET movies/_search {     “query”: {         “bool”: {             “filter”: [                 {                     “term”: {                         “title”: “beautiful”                     }                 },                 {                     “range”: {                         “year”: {                             “gte”: 2016,                             “lte”: 2018                         }                     }                 }             ]         }     } }"></a>filter不会进行相关性的算分，并且会将查出来的结果进行缓存，效率上比 query 高 GET movies/_search {<!-- -->     “query”: {<!-- -->         “bool”: {<!-- -->             “filter”: [                 {<!-- -->                     “term”: {<!-- -->                         “title”: “beautiful”                     }                 },                 {<!-- -->                     “range”: {<!-- -->                         “year”: {<!-- -->                             “gte”: 2016,                             “lte”: 2018                         }                     }                 }             ]         }     } }</h1><h3 id="14、Mapping"><a href="#14、Mapping" class="headerlink" title="14、Mapping"></a>14、Mapping</h3><blockquote>
<p> mapping类似于数据库中的schema，作用如下:<br>         1. 定义索引中的字段类型；<br>         2. 定义字段的数据类型，例如：布尔、字符串、数字、日期…..<br>         3. 字段倒排索引的设置<br> 数据类型<img alt="" height="315" src="https://img-blog.csdnimg.cn/20210703130327728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="753"><br> Mapping的定义语法如下：<br> PUT users {<!-- -->     “mappings”: {<!-- -->         // define your mappings here     } }<br> 定义mapping的建议方式: 写入一个样本文档到临时索引中，ES会自动生成mapping信息，通过访问 mapping信息的api查询mapping的定义，修改自动生成的mapping成为我们需要方式，创建索引，删 除临时索引，简而言之就是 “卸磨杀驴” 。 </p>
</blockquote>
<h3 id="15、常见参数"><a href="#15、常见参数" class="headerlink" title="15、常见参数"></a>15、常见参数</h3><blockquote>
<p> 1）index<br>       可以给属性添加一个 布尔类型的index属性，标识该属性是否能被倒排索引，也就是说是否能通过 该字段进行搜索。<br> 2) null_value<br> 在数据索引进ES的时候，当某些数据为 null 的时候，该数据是不能被搜索的，可以使用 null_value 属性指定一个值，当属性的值为 null 的时候，转换为一个通过 null_value 指 定的值。 null_value属性只能用于Keyword类型的属性 </p>
</blockquote>
<h3 id="16、聚合查询"><a href="#16、聚合查询" class="headerlink" title="16、聚合查询"></a>16、聚合查询</h3><blockquote>
<p> 1）聚合搜索的语法格式如下：<br> GET indexName/_search {<!-- -->     “aggs”: {<!-- -->         “aggs_name”: { #聚合分析的名字是由用户自定义的             “aggs_type”: {<!-- -->                 // aggregation body             }         }     } } 2）给users索引创建mapping信息<br> <img alt="" height="507" src="https://img-blog.csdnimg.cn/20210703165950461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="406"><br> 3）往 users 索引中写入数据<br> <pre><code class="language-html">PUT employee/_bulk<br>&#123;"index": &#123;"_id": 1&#125;&#125;<br>&#123;"id": 1, "name": "Bob", "job": "java", "age": 21, "sal": 8000, "gender": "female"&#125;<br>&#123;"index": &#123;"_id": 2&#125;&#125;<br>&#123;"id": 2, "name": "Rod", "job": "html", "age": 31, "sal": 18000, "gender": "female"&#125;<br>&#123;"index": &#123;"_id": 3&#125;&#125;<br>&#123;"id": 3, "name": "Gaving", "job": "java", "age": 24, "sal": 12000, "gender": "male"&#125;<br>&#123;"index": &#123;"_id": 4&#125;&#125;<br>&#123;"id": 4, "name": "King", "job": "dba", "age": 26, "sal": 15000, "gender": "female"&#125;<br>&#123;"index": &#123;"_id": 5&#125;&#125;<br>&#123;"id": 5, "name": "Jonhson", "job": "dba", "age": 29, "sal": 16000, "gender": "male"&#125;<br>&#123;"index": &#123;"_id": 6&#125;&#125;<br>&#123;"id": 6, "name": "Douge", "job": "java", "age": 41, "sal": 20000, "gender": "female"&#125;<br>&#123;"index": &#123;"_id": 7&#125;&#125;<br>&#123;"id": 7, "name": "cutting", "job": "dba", "age": 27, "sal": 7000, "gender": "male"&#125;<br>&#123;"index": &#123;"_id": 8&#125;&#125;<br>&#123;"id": 8, "name": "Bona", "job": "html", "age": 22, "sal": 14000, "gender": "female"&#125;<br>&#123;"index": &#123;"_id": 9&#125;&#125;<br>&#123;"id": 9, "name": "Shyon", "job": "dba", "age": 20, "sal": 19000, "gender": "female"&#125;<br>&#123;"index": &#123;"_id": 10&#125;&#125;<br>&#123;"id": 10, "name": "James", "job": "html", "age": 18, "sal": 22000, "gender": "male"&#125;<br>&#123;"index": &#123;"_id": 11&#125;&#125;<br>&#123;"id": 11, "name": "Golsling", "job": "java", "age": 32, "sal": 23000, "gender":<br>"female"&#125;<br>&#123;"index": &#123;"_id": 12&#125;&#125;<br>&#123;"id": 12, "name": "Lily", "job": "java", "age": 24, "sal": 2000, "gender": "male"&#125;<br>&#123;"index": &#123;"_id": 13&#125;&#125;<br>&#123;"id": 13, "name": "Jack", "job": "html", "age": 23, "sal": 3000, "gender": "female"&#125;<br>&#123;"index": &#123;"_id": 14&#125;&#125;<br>&#123;"id": 14, "name": "Rose", "job": "java", "age": 36, "sal": 6000, "gender": "female"&#125;<br>&#123;"index": &#123;"_id": 15&#125;&#125;<br>&#123;"id": 15, "name": "Will", "job": "dba", "age": 38, "sal": 4500, "gender": "male"&#125;<br>&#123;"index": &#123;"_id": 16&#125;&#125;<br>&#123;"id": 16, "name": "smith", "job": "java", "age": 32, "sal": 23000, "gender": "male"&#125;</code></pre><br> 4）单值的输出，ES中大多数的数学计算只输出一个值，如：min、max、sum、avg、cardinalit<br>     4.1）查询工资的总和<br>           <img alt="" height="254" src="https://img-blog.csdnimg.cn/20210703170233150.png" width="292"><br>     4.2）查询员工的平均工资<br>           <img alt="" height="257" src="https://img-blog.csdnimg.cn/20210703170322424.png" width="290"><br>     4.3）查询总共有多少个岗位, cardinality的值类似于sql中的 count distinct,即去重统计总数<br>            <img alt="" height="264" src="https://img-blog.csdnimg.cn/20210703170347326.png" width="298"><br>     4.4）查询航班票价的最高值、平均值、最低值<br>            <img alt="" height="483" src="https://img-blog.csdnimg.cn/20210703170430932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="447"><br> 5）多值的输出,ES还有些函数，可以一次性输出很多个统计的数据: terms、stats<br>      5.1）查询工资的信息<br>             <img alt="" height="250" src="https://img-blog.csdnimg.cn/20210703170608578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="316"><br>      5.2）查询到达不同城市的航班数量<br>             <img alt="" height="260" src="https://img-blog.csdnimg.cn/20210703170635852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="368"><br>      5.3）查询每个岗位有多少人<br>             <img alt="" height="260" src="https://img-blog.csdnimg.cn/20210703170720626.png" width="279"><br>      5.4）查询目标地的航班次数以及天气信息<br>             <img alt="" height="417" src="https://img-blog.csdnimg.cn/20210703170751309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="427"><br>      5.5）查询每个岗位下工资的信息(平均工资、最高工资、最少工资等)<br>             <img alt="" height="542" src="https://img-blog.csdnimg.cn/20210703170929821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="493"><br>      5.6）查询不同工种的男女员工数量、然后统计不同工种下男女员工的工资信息<br>               <img alt="" height="572" src="https://img-blog.csdnimg.cn/20210703171012471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="408"><br>      5.7）查询年龄最大的两位员工的信息<br>           <img alt="" height="543" src="https://img-blog.csdnimg.cn/20210703171105176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="382"><br>      5.8）查询不同区间员工工资的统计信息<br>           <img alt="" height="645" src="https://img-blog.csdnimg.cn/2021070317114435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="442"><br>     5.9）以直方图的方式以每5000元为一个区间查看工资信息<br>          <img alt="" height="431" src="https://img-blog.csdnimg.cn/20210703171304558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="553"><br>     5.10）查询平均工资最低的工种<br>          <img alt="" height="525" src="https://img-blog.csdnimg.cn/20210703171412288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="490"><br>     5.11）求工资和工种的信息<br>          <img alt="" height="375" src="https://img-blog.csdnimg.cn/20210703171444218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="351"><br>     5.12）查询年龄大于30岁的员工的平均工资<br>        <img alt="" height="423" src="https://img-blog.csdnimg.cn/20210703171518293.png" width="282"><br>     5.13）查询Java员工的平均工资<br>          <img alt="" height="488" src="https://img-blog.csdnimg.cn/20210703171556873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="303"><br>     5.14）求30岁以上的员工的平均工资和所有员工的平均工资<br>        <img alt="" height="757" src="https://img-blog.csdnimg.cn/20210703171629367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="367"> </p>
</blockquote>
<h3 id="17、推荐搜索"><a href="#17、推荐搜索" class="headerlink" title="17、推荐搜索"></a>17、推荐搜索</h3><blockquote>
<p> 在搜索过程中，因为单词的拼写错误，没有得到任何的结果，希望ES能够给我们一个推荐搜索。<br> <img alt="" height="456" src="https://img-blog.csdnimg.cn/20210703175229434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="596"> </p>
</blockquote>
<h3 id="18、自动补全"><a href="#18、自动补全" class="headerlink" title="18、自动补全"></a>18、自动补全</h3><blockquote>
<p> 自动补全应该是我们在日常的开发过程中最常见的搜索方式了，如百度搜索和京东商品搜索。<br> <img alt="" height="382" src="https://img-blog.csdnimg.cn/20210703175338116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="750"><br> <img alt="" height="671" src="https://img-blog.csdnimg.cn/20210703175400630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="753"><br> 定义mapping：<br> <img alt="" height="824" src="https://img-blog.csdnimg.cn/20210703175531835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="519"><br> <img alt="" height="314" src="https://img-blog.csdnimg.cn/20210703175551768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="462"><br> 前缀搜索<br> <img alt="" height="330" src="https://img-blog.csdnimg.cn/20210703175642732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="366"><br> <img alt="" height="804" src="https://img-blog.csdnimg.cn/20210703175715675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> </p>
</blockquote>
<h3 id="19、高亮显示"><a href="#19、高亮显示" class="headerlink" title="19、高亮显示"></a>19、高亮显示</h3><blockquote>
<p> 高亮显示在实际的应用中也会碰到很多，如下给出了百度和极客时间的两个高亮搜索的案例：<br> <img alt="" height="825" src="https://img-blog.csdnimg.cn/20210703180705816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="925"><br> <img alt="" height="657" src="https://img-blog.csdnimg.cn/2021070318072243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="960"><br> 将所有的包含有 beautiful 的单词高亮显示<br> <img alt="" height="631" src="https://img-blog.csdnimg.cn/20210703180807646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="551"><br> <img alt="" height="636" src="https://img-blog.csdnimg.cn/20210703180825496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> </p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Elasticsearch之JAVA API操作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/18/Elasticsearch%E4%B9%8BJAVA%20API%E6%93%8D%E4%BD%9C/"
    >Elasticsearch之JAVA API操作</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/07/18/Elasticsearch%E4%B9%8BJAVA%20API%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2021-07-18T14:21:56.444Z" itemprop="datePublished">2021-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Elasticsearch/">Elasticsearch</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>title: Elasticsearch之JAVA API操作<br>categories:</p>
<ul>
<li>elasticsearch</li>
</ul>
<p>—### 1、JavaAPI-环境准备</p>
<blockquote>
<p> 1.1、创建一个springboot项目<br>       <img alt="" height="300" src="https://img-blog.csdnimg.cn/2021062012261018.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="477">      pom的依赖如下：<br> <pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>&lt;project xmlns="<a target="_blank" rel="noopener" href="http://maven.apache.org/POM/4.0.0&quot;">http://maven.apache.org/POM/4.0.0&quot;</a><br>         xmlns:xsi="<a target="_blank" rel="noopener" href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>         xsi:schemaLocation="<a target="_blank" rel="noopener" href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> <a target="_blank" rel="noopener" href="http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</a>&gt;<br>    &lt;parent&gt;<br>        &lt;artifactId&gt;kgf-java-learning&lt;/artifactId&gt;<br>        &lt;groupId&gt;com.kgf.learning&lt;/groupId&gt;<br>        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br>        &lt;relativePath&gt;../kgf-java-learning/pom.xml&lt;/relativePath&gt;<br>    &lt;/parent&gt;<br>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</p>
</blockquote>
<pre><code>&amp;lt;groupId&amp;gt;com.kgf.es7.8&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;kgf-es7.8-api&amp;lt;/artifactId&amp;gt;
&amp;lt;properties&amp;gt;
    &amp;lt;!--自定义elasticsearch版本--&amp;gt;
    &amp;lt;elasticsearch.version&amp;gt;7.8.0&amp;lt;/elasticsearch.version&amp;gt;
    &amp;lt;lombok.version&amp;gt;1.18.16&amp;lt;/lombok.version&amp;gt;
    &amp;lt;fastjson.version&amp;gt;1.2.75&amp;lt;/fastjson.version&amp;gt;
&amp;lt;/properties&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;$&#123;fastjson.version&#125;&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--引入lombok依赖--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;$&#123;lombok.version&#125;&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-data-elasticsearch&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--引入Juntil单元测试 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-configuration-processor&amp;lt;/artifactId&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--jsoup解析网页，tiks解析视频音乐--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.jsoup&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jsoup&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.10.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.2.11.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;
                &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
</code></pre>
<p>&lt;/project&gt;</code></pre><br> <pre><code>ElasticConfig.java如下：</code></pre><br> <pre><code class="language-java">package com.kgf.es.config;</p>
<p>import org.apache.http.HttpHost;<br>import org.elasticsearch.client.RestClient;<br>import org.elasticsearch.client.RestHighLevelClient;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;</p>
<p>@Configuration<br>public class ElasticConfig &#123;</p>
<pre><code>@Bean
public RestHighLevelClient restHighLevelClient()&#123;
    RestHighLevelClient client = new RestHighLevelClient(
            RestClient.builder(new HttpHost(&quot;127.0.0.1&quot;, 9200, &quot;http&quot;))
    );
    return client;
&#125;
</code></pre>
<p>}<br></code></pre><br> 1.2、ESApplication.java如下<br> <pre><code class="language-java">package com.kgf.es;</p>
<p>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;</p>
<p>@SpringBootApplication<br>public class ESApplication &#123;</p>
<pre><code>public static void main(String[] args) &#123;

    SpringApplication.run(ESApplication.class,args);

&#125;
</code></pre>
<p>}<br></code></pre> 
   </p>
<h3 id="2、JavaAPI-索引-创建"><a href="#2、JavaAPI-索引-创建" class="headerlink" title="2、JavaAPI-索引-创建"></a>2、JavaAPI-索引-创建</h3><blockquote>
<p> 2.1、在一个Junit测试类创建索引<br> <pre><code class="language-java">package es7;</p>
</blockquote>
<p>import com.kgf.es.ESApplication;<br>import org.elasticsearch.client.RequestOptions;<br>import org.elasticsearch.client.RestHighLevelClient;<br>import org.elasticsearch.client.indices.CreateIndexRequest;<br>import org.elasticsearch.client.indices.CreateIndexResponse;<br>import org.junit.Test;<br>import org.junit.runner.RunWith;<br>import org.springframework.boot.test.context.SpringBootTest;<br>import org.springframework.test.context.junit4.SpringRunner;</p>
<p>import javax.annotation.Resource;<br>import java.io.IOException;</p>
<p>@RunWith(SpringRunner.class)<br>@SpringBootTest(classes = ESApplication.class,webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)<br>public class EsApplicationTest &#123;</p>
<pre><code>@Resource
private RestHighLevelClient restHighLevelClient;

/***
 * 创建索引
 */
@Test
public void createIndexTest()&#123;
    try &#123;
        //创建索引对象
        CreateIndexRequest indexRequest = new CreateIndexRequest(&quot;user&quot;);
        //客户端执行请求
        CreateIndexResponse response = restHighLevelClient.indices().create(indexRequest, RequestOptions.DEFAULT);

        boolean acknowledged = response.isAcknowledged();
        // 响应状态
        System.out.println(&quot;操作状态 = &quot; + acknowledged);
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<p>}<br></code></pre><br> 执行：<br> <img alt="" height="245" src="https://img-blog.csdnimg.cn/20210620123925330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="724"><br> 查看索引：<br> <img alt="" height="503" src="https://img-blog.csdnimg.cn/20210620124000441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1100"> </p>
<h3 id="3、索引-查询-amp-删除"><a href="#3、索引-查询-amp-删除" class="headerlink" title="3、索引-查询 &amp; 删除"></a>3、索引-查询 &amp; 删除</h3><blockquote>
<p> <strong>3.1、查询</strong><br> <pre><code class="language-java">   /***<br>     * 查询索引<br>     */<br>    @Test<br>    public void getIndexTest()&#123;<br>        try &#123;<br>            // 查询索引 - 请求对象<br>            GetIndexRequest request = new GetIndexRequest("user");<br>            // 发送请求，获取响应<br>            GetIndexResponse response = restHighLevelClient.indices().get(request,<br>                    RequestOptions.DEFAULT);</p>
</blockquote>
<pre><code>        System.out.println(&quot;aliases:&quot;+response.getAliases());
        System.out.println(&quot;mappings:&quot;+response.getMappings());
        System.out.println(&quot;settings:&quot;+response.getSettings());
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;&lt;/code&gt;&lt;/pre&gt; 
</code></pre>
<p> 后台打印：<br> <pre><code class="language-java">aliases:&#123;user=[]&#125;<br>mappings:&#123;user=org.elasticsearch.cluster.metadata.MappingMetadata@872c984c&#125;<br>settings:&#123;user=&#123;"index.creation_date":"1624163950299","index.number_of_replicas":"1","index.number_of_shards":"1","index.provided_name":"user","index.uuid":"XvPUSw3rR7CjmrGk0BtdCw","index.version.created":"7080099"&#125;&#125;<br></code></pre><br> <strong>3.2、删除</strong><br> <pre><code class="language-java"> /***<br>     * 删除索引<br>     */<br>    @Test<br>    public void DelIndexTest()&#123;<br>        try &#123;<br>            // 删除索引 - 请求对象<br>            DeleteIndexRequest request = new DeleteIndexRequest("user");<br>            // 发送请求，获取响应<br>            AcknowledgedResponse response = restHighLevelClient.indices().delete(request,RequestOptions.DEFAULT);<br>            // 操作结果<br>            System.out.println("操作结果 ： " + response.isAcknowledged());<br>        &#125; catch (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;</code></pre><br> 后台打印：<br> <pre><code>操作结果 ： true<br></code></pre> 
   </p>
<h3 id="4、JavaAPI-文档-新增-amp-修改"><a href="#4、JavaAPI-文档-新增-amp-修改" class="headerlink" title="4、JavaAPI-文档-新增 &amp; 修改"></a>4、JavaAPI-文档-新增 &amp; 修改</h3><blockquote>
<p> <strong>4.1、新增</strong><br> <pre><code class="language-java">/***<br>     * 添加文档<br>     */<br>    @Test<br>    public void addDocumentTest()&#123;<br>        try &#123;<br>            // 新增文档 - 请求对象<br>            IndexRequest request = new IndexRequest();<br>            // 设置索引及唯一性标识<br>            request.index("user").id("1001");</p>
</blockquote>
<pre><code>        // 创建数据对象
        User user = new User();
        user.setName(&quot;zhangsan&quot;);
        user.setAge(30);
        user.setSex(&quot;男&quot;);

        ObjectMapper objectMapper = new ObjectMapper();
        String productJson = objectMapper.writeValueAsString(user);
        // 添加文档数据，数据格式为 JSON 格式
        request.source(productJson, XContentType.JSON);
        // 客户端发送请求，获取响应对象
        IndexResponse response = restHighLevelClient.index(request, RequestOptions.DEFAULT);
        //打印结果信息
        System.out.println(&quot;_index:&quot; + response.getIndex());
        System.out.println(&quot;_id:&quot; + response.getId());
        System.out.println(&quot;_result:&quot; + response.getResult());
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;&lt;/code&gt;&lt;/pre&gt; 
</code></pre>
<p> 后台打印：<br> <img alt="" height="210" src="https://img-blog.csdnimg.cn/20210620172914512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="668"><br> <strong>4.2、修改</strong><br> <pre><code class="language-java">/***<br>     * 修改文档信息<br>     */<br>    @Test<br>    public void updateDocument()&#123;<br>        try &#123;<br>            // 修改文档 - 请求对象<br>            UpdateRequest request = new UpdateRequest();<br>            // 配置修改参数<br>            request.index("user").id("1001");<br>            // 设置请求体，对数据进行修改<br>            request.doc(XContentType.JSON, "sex", "女");<br>            // 客户端发送请求，获取响应对象<br>            UpdateResponse response = restHighLevelClient.update(request, RequestOptions.DEFAULT);<br>            System.out.println("_index:" + response.getIndex());<br>            System.out.println("_id:" + response.getId());<br>            System.out.println("_result:" + response.getResult());<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;</code></pre><br> 后台打印：<br> <img alt="" height="188" src="https://img-blog.csdnimg.cn/20210620173126639.png" width="699"> </p>
<h3 id="5、文档-查询-amp-删除"><a href="#5、文档-查询-amp-删除" class="headerlink" title="5、文档-查询 &amp; 删除"></a>5、文档-查询 &amp; 删除</h3><blockquote>
<p> <strong>5.1、查询文档</strong><br> <pre><code class="language-java"> /***<br>     * 查询文档信息<br>     */<br>    @Test<br>    public void queryDocument()&#123;<br>        try &#123;<br>            //1.创建请求对象<br>            GetRequest request = new GetRequest().index("user").id("1001");<br>            //2.客户端发送请求，获取响应对象<br>            GetResponse response = restHighLevelClient.get(request, RequestOptions.DEFAULT);<br>            //打印结果信息<br>            System.out.println("_index:" + response.getIndex());<br>            System.out.println("_type:" + response.getType());<br>            System.out.println("_id:" + response.getId());<br>            System.out.println("source:" + response.getSourceAsString());<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;</code></pre><br> 后台打印：<br> <pre><code class="language-java">_index:user<br>_type:_doc<br>_id:1001<br>source:&#123;"name":"zhangsan","age":30,"sex":"男"&#125;</p>
</blockquote>
<p>Process finished with exit code 0<br></code></pre><br> <strong>5.2、删除</strong><br> <pre><code class="language-java"> /***<br>     * 删除文档操作<br>     * @throws IOException<br>     */<br>    @Test<br>    public void delDocumentTest() throws IOException &#123;<br>        //创建请求对象<br>        DeleteRequest request = new DeleteRequest().index("user").id("1001");<br>        //客户端发送请求，获取响应对象<br>        DeleteResponse response = restHighLevelClient.delete(request, RequestOptions.DEFAULT);<br>        //打印信息<br>        System.out.println(response.toString());<br>    &#125;</code></pre><br> 后台打印：<br> <pre><code class="language-java">DeleteResponse[index=user,type=_doc,id=1001,version=16,result=deleted,shards=ShardInfo&#123;total=2, successful=1, failures=[]&#125;]</p>
<p>Process finished with exit code 0<br></code></pre> 
   </p>
<h3 id="6、文档-批量新增-amp-批量删除"><a href="#6、文档-批量新增-amp-批量删除" class="headerlink" title="6、文档-批量新增 &amp; 批量删除"></a>6、文档-批量新增 &amp; 批量删除</h3><blockquote>
<p> <strong>6.1、批量新增</strong><br> <pre><code class="language-java"> /***<br>     * 测试批量插入操作<br>     * @throws IOException<br>     */<br>    @Test<br>    public void bulkInsertRequestTest() throws IOException &#123;<br>        //创建批量新增请求对象<br>        BulkRequest request = new BulkRequest();<br>        request.add(new<br>                IndexRequest().index("user").id("1001").source(XContentType.JSON, "name",<br>                "zhangsan"));<br>        request.add(new<br>                IndexRequest().index("user").id("1002").source(XContentType.JSON, "name",<br>                "lisi"));<br>        request.add(new<br>                IndexRequest().index("user").id("1003").source(XContentType.JSON, "name",<br>                "wangwu"));<br>        //客户端发送请求，获取响应对象<br>        BulkResponse responses = restHighLevelClient.bulk(request, RequestOptions.DEFAULT);<br>        //打印结果信息<br>        System.out.println("took:" + responses.getTook());<br>        System.out.println("items:" + responses.getItems());<br>    &#125;</code></pre><br> 后台打印<br> <pre><code class="language-java">took:294ms<br>items:[Lorg.elasticsearch.action.bulk.BulkItemResponse;@2beee7ff</p>
</blockquote>
<p>Process finished with exit code 0<br></code></pre><br> <strong>6.2、批量删除</strong><br> <pre><code class="language-java">  /***<br>     * 测试批量插入操作<br>     * @throws IOException<br>     */<br>    @Test<br>    public void bulkDeleteRequestTest() throws IOException &#123;<br>        //创建批量删除请求对象<br>        BulkRequest request = new BulkRequest();<br>        request.add(new DeleteRequest().index("user").id("1001"));<br>        request.add(new DeleteRequest().index("user").id("1002"));<br>        request.add(new DeleteRequest().index("user").id("1003"));<br>        //客户端发送请求，获取响应对象<br>        BulkResponse responses = restHighLevelClient.bulk(request, RequestOptions.DEFAULT);<br>        //打印结果信息<br>        System.out.println("took:" + responses.getTook());<br>        System.out.println("items:" + responses.getItems());<br>    &#125;</code></pre><br> 后台打印<br> <pre><code class="language-java">took:108ms<br>items:[Lorg.elasticsearch.action.bulk.BulkItemResponse;@7b02881e</p>
<p>Process finished with exit code 0</p>
<p></code></pre> 
   </p>
<h3 id="7、文档-高级查询-全量查询"><a href="#7、文档-高级查询-全量查询" class="headerlink" title="7、文档-高级查询-全量查询"></a>7、文档-高级查询-全量查询</h3><blockquote>
<p> 7.1、先批量增加数据<br> <pre><code class="language-java"> /***<br>     * 测试批量插入操作<br>     * @throws IOException<br>     */<br>    @Test<br>    public void bulkInsertRequestTest() throws IOException &#123;<br>        //创建批量新增请求对象<br>        BulkRequest request = new BulkRequest();<br>        request.add(new IndexRequest().index("user").id("1001").source(XContentType.JSON, "name", "zhangsan", "age", "10", "sex","女"));<br>        request.add(new IndexRequest().index("user").id("1002").source(XContentType.JSON, "name", "lisi", "age", "30", "sex","女"));<br>        request.add(new IndexRequest().index("user").id("1003").source(XContentType.JSON, "name", "wangwu1", "age", "40", "sex","男"));<br>        request.add(new IndexRequest().index("user").id("1004").source(XContentType.JSON, "name", "wangwu2", "age", "20", "sex","女"));<br>        request.add(new IndexRequest().index("user").id("1005").source(XContentType.JSON, "name", "wangwu3", "age", "50", "sex","男"));<br>        request.add(new IndexRequest().index("user").id("1006").source(XContentType.JSON, "name", "wangwu4", "age", "20", "sex","男"));<br>        //客户端发送请求，获取响应对象<br>        BulkResponse responses = restHighLevelClient.bulk(request, RequestOptions.DEFAULT);<br>        //打印结果信息<br>        System.out.println("took:" + responses.getTook());<br>        System.out.println("items:" + responses.getItems());<br>    &#125;</code></pre><br> 后台打印<br> <pre><code class="language-java">took:168ms<br>items:[Lorg.elasticsearch.action.bulk.BulkItemResponse;@2beee7ff</p>
</blockquote>
<p>Process finished with exit code 0<br></code></pre><br> <strong>查询所有索引数据</strong><br> <pre><code class="language-java">/***<br>     * 查询所有索引数据<br>     * @throws IOException<br>     */<br>    @Test<br>    public void searchRequestTest() throws IOException &#123;<br>        // 创建搜索请求对象<br>        SearchRequest request = new SearchRequest();<br>        request.indices("user");<br>        // 构建查询的请求体<br>        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();<br>        // 查询所有数据<br>        sourceBuilder.query(QueryBuilders.matchAllQuery());<br>        request.source(sourceBuilder);<br>        SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>        // 查询匹配<br>        SearchHits hits = response.getHits();<br>        System.out.println("took:" + response.getTook());<br>        System.out.println("timeout:" + response.isTimedOut());<br>        System.out.println("total:" + hits.getTotalHits());<br>        System.out.println("MaxScore:" + hits.getMaxScore());<br>        System.out.println("hits========&gt;&gt;");<br>        for (SearchHit hit : hits) &#123;<br>            //输出每条查询的结果信息<br>            System.out.println(hit.getSourceAsString());<br>        &#125;<br>        System.out.println("&lt;&lt;========");<br>    &#125;</code></pre><br> 后台打印<br> <pre><code class="language-java">took:2ms<br>timeout:false<br>total:6 hits<br>MaxScore:1.0<br>hits========&gt;&gt;<br>&#123;"name":"zhangsan","age":"10","sex":"女"&#125;<br>&#123;"name":"lisi","age":"30","sex":"女"&#125;<br>&#123;"name":"wangwu1","age":"40","sex":"男"&#125;<br>&#123;"name":"wangwu2","age":"20","sex":"女"&#125;<br>&#123;"name":"wangwu3","age":"50","sex":"男"&#125;<br>&#123;"name":"wangwu4","age":"20","sex":"男"&#125;<br>&lt;&lt;========</p>
<p>Process finished with exit code 0<br></code></pre> 
   </p>
<h3 id="8、文档-高级查询-分页查询-amp-条件查询-amp-查询排序"><a href="#8、文档-高级查询-分页查询-amp-条件查询-amp-查询排序" class="headerlink" title="8、文档-高级查询-分页查询 &amp; 条件查询 &amp; 查询排序"></a>8、文档-高级查询-分页查询 &amp; 条件查询 &amp; 查询排序</h3><blockquote>
<p> <strong>8.1、条件查询</strong><br> <pre><code class="language-java"> /***<br>     * 条件查询<br>     * @throws IOException<br>     */<br>    @Test<br>    public void queryByConditiontest() throws IOException &#123;<br>        // 创建搜索请求对象<br>        SearchRequest request = new SearchRequest();<br>        request.indices("user");<br>        // 构建查询的请求体<br>        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();<br>        sourceBuilder.query(QueryBuilders.termQuery("age", "30"));<br>        request.source(sourceBuilder);<br>        SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>        // 查询匹配<br>        SearchHits hits = response.getHits();<br>        System.out.println("took:" + response.getTook());<br>        System.out.println("timeout:" + response.isTimedOut());<br>        System.out.println("total:" + hits.getTotalHits());<br>        System.out.println("MaxScore:" + hits.getMaxScore());<br>        System.out.println("hits========&gt;&gt;");<br>        for (SearchHit hit : hits) &#123;<br>            //输出每条查询的结果信息<br>            System.out.println(hit.getSourceAsString());<br>        &#125;<br>        System.out.println("&lt;&lt;========");<br>    &#125;</code></pre><br> 后台打印<br> <pre><code class="language-java">took:1ms<br>timeout:false<br>total:1 hits<br>MaxScore:1.0<br>hits========&gt;&gt;<br>&#123;"name":"lisi","age":"30","sex":"女"&#125;<br>&lt;&lt;========<br></code></pre><br> <strong>8.2、分页查询</strong> </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">     * 条件查询</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void queryByPagetest() throws IOException &#123;</span><br><span class="line">        // 创建搜索请求对象</span><br><span class="line">        SearchRequest request = new SearchRequest();</span><br><span class="line">        request.indices(&quot;user&quot;);</span><br><span class="line">        // 构建查询的请求体</span><br><span class="line">        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();</span><br><span class="line">        sourceBuilder.query(QueryBuilders.matchAllQuery());</span><br><span class="line">        // 分页查询</span><br><span class="line">        // 当前页其实索引(第一条数据的顺序号)， from</span><br><span class="line">        sourceBuilder.from(0);</span><br><span class="line"></span><br><span class="line">        // 每页显示多少条 size</span><br><span class="line">        sourceBuilder.size(2);</span><br><span class="line">        request.source(sourceBuilder);</span><br><span class="line">        SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        // 查询匹配</span><br><span class="line">        SearchHits hits = response.getHits();</span><br><span class="line">        System.out.println(&quot;took:&quot; + response.getTook());</span><br><span class="line">        System.out.println(&quot;timeout:&quot; + response.isTimedOut());</span><br><span class="line">        System.out.println(&quot;total:&quot; + hits.getTotalHits());</span><br><span class="line">        System.out.println(&quot;MaxScore:&quot; + hits.getMaxScore());</span><br><span class="line">        System.out.println(&quot;hits========&amp;gt;&amp;gt;&quot;);</span><br><span class="line">        for (SearchHit hit : hits) &#123;</span><br><span class="line">            //输出每条查询的结果信息</span><br><span class="line">            System.out.println(hit.getSourceAsString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&amp;lt;&amp;lt;========&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>后台打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">took:1ms</span><br><span class="line">timeout:false</span><br><span class="line">total:6 hits</span><br><span class="line">MaxScore:1.0</span><br><span class="line">hits========&amp;gt;&amp;gt;</span><br><span class="line">&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:&quot;10&quot;,&quot;sex&quot;:&quot;女&quot;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;女&quot;&#125;</span><br><span class="line">&amp;lt;&amp;lt;========</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-3、查询排序"><a href="#8-3、查询排序" class="headerlink" title="8.3、查询排序"></a>8.3、查询排序</h3><blockquote>
 <pre><code class="language-java">/***
     * 条件查询
     * @throws IOException
     */
    @Test
    public void queryByOrdertest() throws IOException &#123;
        // 创建搜索请求对象
        SearchRequest request = new SearchRequest();
        request.indices("user");
</blockquote>
<pre><code>    // 构建查询的请求体
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    sourceBuilder.query(QueryBuilders.matchAllQuery());
    // 排序
    sourceBuilder.sort(&quot;age&quot;, SortOrder.ASC);
    request.source(sourceBuilder);
    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);
    // 查询匹配
    SearchHits hits = response.getHits();
    System.out.println(&quot;took:&quot; + response.getTook());
    System.out.println(&quot;timeout:&quot; + response.isTimedOut());
    System.out.println(&quot;total:&quot; + hits.getTotalHits());
    System.out.println(&quot;MaxScore:&quot; + hits.getMaxScore());
    System.out.println(&quot;hits========&amp;gt;&amp;gt;&quot;);
    for (SearchHit hit : hits) &#123;
        //输出每条查询的结果信息
        System.out.println(hit.getSourceAsString());
    &#125;
    System.out.println(&quot;&amp;lt;&amp;lt;========&quot;);
&#125;&lt;/code&gt;&lt;/pre&gt; 
</code></pre>
<p> 后台打印<br> <pre><code class="language-java">took:1ms<br>timeout:false<br>total:6 hits<br>MaxScore:NaN<br>hits========&gt;&gt;<br>&#123;"name":"zhangsan","age":"10","sex":"女"&#125;<br>&#123;"name":"wangwu2","age":"20","sex":"女"&#125;<br>&#123;"name":"wangwu4","age":"20","sex":"男"&#125;<br>&#123;"name":"lisi","age":"30","sex":"女"&#125;<br>&#123;"name":"wangwu1","age":"40","sex":"男"&#125;<br>&#123;"name":"wangwu3","age":"50","sex":"男"&#125;<br>&lt;&lt;========<br></code></pre> 
   </p>
<h3 id="9、高级查询-组合查询-amp-范围查询"><a href="#9、高级查询-组合查询-amp-范围查询" class="headerlink" title="9、高级查询-组合查询 &amp; 范围查询"></a>9、高级查询-组合查询 &amp; 范围查询</h3><blockquote>
 <h3>9.1、组合查询</h3> 
 <pre><code class="language-java"> /***
     * 条件查询
     * @throws IOException
     */
    @Test
    public void queryByCombinattest() throws IOException &#123;
        // 创建搜索请求对象
        SearchRequest request = new SearchRequest();
        request.indices("user");
        // 构建查询的请求体
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
        // 必须包含
        boolQueryBuilder.must(QueryBuilders.matchQuery("age", "30"));
        // 一定不含
        boolQueryBuilder.mustNot(QueryBuilders.matchQuery("name", "zhangsan"));
        // 可能包含
        boolQueryBuilder.should(QueryBuilders.matchQuery("sex", "男"));
        sourceBuilder.query(boolQueryBuilder);
        request.source(sourceBuilder);
        SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);
        // 查询匹配
        SearchHits hits = response.getHits();
        System.out.println("took:" + response.getTook());
        System.out.println("timeout:" + response.isTimedOut());
        System.out.println("total:" + hits.getTotalHits());
        System.out.println("MaxScore:" + hits.getMaxScore());
        System.out.println("hits========&gt;&gt;");
        for (SearchHit hit : hits) &#123;
            //输出每条查询的结果信息
            System.out.println(hit.getSourceAsString());
        &#125;
        System.out.println("&lt;&lt;========");
    &#125;</code></pre> 
 后台打印 
 <pre><code class="language-java">took:28ms
timeout:false
total:1 hits
MaxScore:1.0
hits========&gt;&gt;
&#123;"name":"lisi","age":"30","sex":"女"&#125;
&lt;&lt;========
</blockquote>
<p>Process finished with exit code 0<br></code></pre><br> <strong>9.2、范围查询</strong><br> <pre><code class="language-java">import com.lun.elasticsearch.hello.ConnectElasticsearch;<br>import com.lun.elasticsearch.hello.ElasticsearchTask;<br>import org.elasticsearch.action.search.SearchRequest;<br>import org.elasticsearch.action.search.SearchResponse;<br>import org.elasticsearch.client.RequestOptions;<br>import org.elasticsearch.index.query.BoolQueryBuilder;<br>import org.elasticsearch.index.query.QueryBuilders;<br>import org.elasticsearch.index.query.RangeQueryBuilder;<br>import org.elasticsearch.search.SearchHit;<br>import org.elasticsearch.search.SearchHits;<br>import org.elasticsearch.search.builder.SearchSourceBuilder;<br>import org.elasticsearch.search.sort.SortOrder;</p>
<p>public class QueryDoc &#123;</p>
<pre><code>public static final ElasticsearchTask SEARCH_BY_RANGE = client -&amp;gt; &#123;
    // 创建搜索请求对象
    SearchRequest request = new SearchRequest();
    request.indices(&quot;user&quot;);
    // 构建查询的请求体
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery(&quot;age&quot;);
    // 大于等于
    //rangeQuery.gte(&quot;30&quot;);
    // 小于等于
    rangeQuery.lte(&quot;40&quot;);
    sourceBuilder.query(rangeQuery);
    request.source(sourceBuilder);
    SearchResponse response = client.search(request, RequestOptions.DEFAULT);
    // 查询匹配
    SearchHits hits = response.getHits();
    System.out.println(&quot;took:&quot; + response.getTook());
    System.out.println(&quot;timeout:&quot; + response.isTimedOut());
    System.out.println(&quot;total:&quot; + hits.getTotalHits());
    System.out.println(&quot;MaxScore:&quot; + hits.getMaxScore());
    System.out.println(&quot;hits========&amp;gt;&amp;gt;&quot;);
    for (SearchHit hit : hits) &#123;
    //输出每条查询的结果信息
        System.out.println(hit.getSourceAsString());
    &#125;
    System.out.println(&quot;&amp;lt;&amp;lt;========&quot;);
&#125;;

public static void main(String[] args) &#123;
    ConnectElasticsearch.connect(SEARCH_BY_RANGE);
&#125;
</code></pre>
<p>}</p>
<p></code></pre><br> 后台打印<br> <pre><code class="language-java">took:1ms<br>timeout:false<br>total:5 hits<br>MaxScore:1.0<br>hits========&gt;&gt;<br>&#123;"name":"zhangsan","age":"10","sex":"女"&#125;<br>&#123;"name":"lisi","age":"30","sex":"女"&#125;<br>&#123;"name":"wangwu1","age":"40","sex":"男"&#125;<br>&#123;"name":"wangwu2","age":"20","sex":"女"&#125;<br>&#123;"name":"wangwu4","age":"20","sex":"男"&#125;<br>&lt;&lt;========</p>
<p>Process finished with exit code 0<br></code></pre> </p>
<h3 id="10、高级查询-模糊查询-amp-高亮查询"><a href="#10、高级查询-模糊查询-amp-高亮查询" class="headerlink" title="10、高级查询-模糊查询 &amp; 高亮查询"></a><strong>10、</strong>高级查询-模糊查询 &amp; 高亮查询</h3><blockquote>
<p> <strong>10.1、模糊查询</strong><br> <pre><code class="language-java">import com.lun.elasticsearch.hello.ConnectElasticsearch;<br>import com.lun.elasticsearch.hello.ElasticsearchTask;<br>import org.elasticsearch.action.search.SearchRequest;<br>import org.elasticsearch.action.search.SearchResponse;<br>import org.elasticsearch.client.RequestOptions;<br>import org.elasticsearch.common.unit.Fuzziness;<br>import org.elasticsearch.index.query.BoolQueryBuilder;<br>import org.elasticsearch.index.query.QueryBuilders;<br>import org.elasticsearch.index.query.RangeQueryBuilder;<br>import org.elasticsearch.search.SearchHit;<br>import org.elasticsearch.search.SearchHits;<br>import org.elasticsearch.search.builder.SearchSourceBuilder;<br>import org.elasticsearch.search.sort.SortOrder;</p>
</blockquote>
<p>public class QueryDoc &#123;</p>
<pre><code>public static final ElasticsearchTask SEARCH_BY_FUZZY_CONDITION = client -&amp;gt; &#123;
    // 创建搜索请求对象
    SearchRequest request = new SearchRequest();
    request.indices(&quot;user&quot;);
    // 构建查询的请求体
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    sourceBuilder.query(QueryBuilders.fuzzyQuery(&quot;name&quot;,&quot;wangwu&quot;).fuzziness(Fuzziness.ONE));
    request.source(sourceBuilder);
    SearchResponse response = client.search(request, RequestOptions.DEFAULT);
    // 查询匹配
    SearchHits hits = response.getHits();
    System.out.println(&quot;took:&quot; + response.getTook());
    System.out.println(&quot;timeout:&quot; + response.isTimedOut());
    System.out.println(&quot;total:&quot; + hits.getTotalHits());
    System.out.println(&quot;MaxScore:&quot; + hits.getMaxScore());
    System.out.println(&quot;hits========&amp;gt;&amp;gt;&quot;);
    for (SearchHit hit : hits) &#123;
        //输出每条查询的结果信息
        System.out.println(hit.getSourceAsString());
    &#125;
    System.out.println(&quot;&amp;lt;&amp;lt;========&quot;);
&#125;;


public static void main(String[] args) &#123;
</code></pre>
<p>//        ConnectElasticsearch.connect(SEARCH_ALL);<br>//        ConnectElasticsearch.connect(SEARCH_BY_CONDITION);<br>//        ConnectElasticsearch.connect(SEARCH_BY_PAGING);<br>//        ConnectElasticsearch.connect(SEARCH_WITH_ORDER);<br>//        ConnectElasticsearch.connect(SEARCH_BY_BOOL_CONDITION);<br>//        ConnectElasticsearch.connect(SEARCH_BY_RANGE);<br>        ConnectElasticsearch.connect(SEARCH_BY_FUZZY_CONDITION);<br>    }</p>
<p>}<br></code></pre><br> 后台打印<br> <pre><code class="language-java">took:152ms<br>timeout:false<br>total:4 hits<br>MaxScore:1.2837042<br>hits========&gt;&gt;<br>&#123;"name":"wangwu1","age":"40","sex":"男"&#125;<br>&#123;"name":"wangwu2","age":"20","sex":"女"&#125;<br>&#123;"name":"wangwu3","age":"50","sex":"男"&#125;<br>&#123;"name":"wangwu4","age":"20","sex":"男"&#125;<br>&lt;&lt;========</p>
<p>Process finished with exit code 0<br></code></pre><br> <strong>10.2、高亮查询</strong><br> <pre><code class="language-java">import com.lun.elasticsearch.hello.ConnectElasticsearch;<br>import com.lun.elasticsearch.hello.ElasticsearchTask;<br>import org.elasticsearch.action.search.SearchRequest;<br>import org.elasticsearch.action.search.SearchResponse;<br>import org.elasticsearch.client.RequestOptions;<br>import org.elasticsearch.common.unit.Fuzziness;<br>import org.elasticsearch.index.query.BoolQueryBuilder;<br>import org.elasticsearch.index.query.QueryBuilders;<br>import org.elasticsearch.index.query.RangeQueryBuilder;<br>import org.elasticsearch.index.query.TermsQueryBuilder;<br>import org.elasticsearch.search.SearchHit;<br>import org.elasticsearch.search.SearchHits;<br>import org.elasticsearch.search.builder.SearchSourceBuilder;<br>import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;<br>import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;<br>import org.elasticsearch.search.sort.SortOrder;</p>
<p>import java.util.Map;</p>
<p>public class QueryDoc &#123;</p>
<pre><code>public static final ElasticsearchTask SEARCH_WITH_HIGHLIGHT = client -&amp;gt; &#123;
    // 高亮查询
    SearchRequest request = new SearchRequest().indices(&quot;user&quot;);
    //2.创建查询请求体构建器
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    //构建查询方式：高亮查询
    TermsQueryBuilder termsQueryBuilder =
            QueryBuilders.termsQuery(&quot;name&quot;,&quot;zhangsan&quot;);
    //设置查询方式
    sourceBuilder.query(termsQueryBuilder);
    //构建高亮字段
    HighlightBuilder highlightBuilder = new HighlightBuilder();
    highlightBuilder.preTags(&quot;&amp;lt;font color=&#39;red&#39;&amp;gt;&quot;);//设置标签前缀
    highlightBuilder.postTags(&quot;&amp;lt;/font&amp;gt;&quot;);//设置标签后缀
    highlightBuilder.field(&quot;name&quot;);//设置高亮字段
    //设置高亮构建对象
    sourceBuilder.highlighter(highlightBuilder);
    //设置请求体
    request.source(sourceBuilder);
    //3.客户端发送请求，获取响应对象
    SearchResponse response = client.search(request, RequestOptions.DEFAULT);
    //4.打印响应结果
    SearchHits hits = response.getHits();
    System.out.println(&quot;took::&quot;+response.getTook());
    System.out.println(&quot;time_out::&quot;+response.isTimedOut());
    System.out.println(&quot;total::&quot;+hits.getTotalHits());
    System.out.println(&quot;max_score::&quot;+hits.getMaxScore());
    System.out.println(&quot;hits::::&amp;gt;&amp;gt;&quot;);
    for (SearchHit hit : hits) &#123;
        String sourceAsString = hit.getSourceAsString();
        System.out.println(sourceAsString);
        //打印高亮结果
        Map&amp;lt;String, HighlightField&amp;gt; highlightFields = hit.getHighlightFields();
        System.out.println(highlightFields);
    &#125;
    System.out.println(&quot;&amp;lt;&amp;lt;::::&quot;);
&#125;;


public static void main(String[] args) &#123;
    ConnectElasticsearch.connect(SEARCH_WITH_HIGHLIGHT);
&#125;
</code></pre>
<p>}<br></code></pre><br> 后台打印<br> <pre><code class="language-java">took::672ms<br>time_out::false<br>total::1 hits<br>max_score::1.0<br>hits::::&gt;&gt;<br>&#123;"name":"zhangsan","age":"10","sex":"女"&#125;<br>&#123;name=[name], fragments[[&lt;font color='red'&gt;zhangsan&lt;/font&gt;]]&#125;<br>&lt;&lt;::::</p>
<p>Process finished with exit code 0<br></code></pre> 
   </p>
<h3 id="11、高级查询-最大值查询-amp-分组查询"><a href="#11、高级查询-最大值查询-amp-分组查询" class="headerlink" title="11、高级查询-最大值查询 &amp; 分组查询"></a>11、高级查询-最大值查询 &amp; 分组查询</h3><blockquote>
<p> <strong>1、最大值查询</strong><br> <pre><code class="language-java">import com.lun.elasticsearch.hello.ConnectElasticsearch;<br>import com.lun.elasticsearch.hello.ElasticsearchTask;<br>import org.elasticsearch.action.search.SearchRequest;<br>import org.elasticsearch.action.search.SearchResponse;<br>import org.elasticsearch.client.RequestOptions;<br>import org.elasticsearch.common.unit.Fuzziness;<br>import org.elasticsearch.index.query.BoolQueryBuilder;<br>import org.elasticsearch.index.query.QueryBuilders;<br>import org.elasticsearch.index.query.RangeQueryBuilder;<br>import org.elasticsearch.index.query.TermsQueryBuilder;<br>import org.elasticsearch.search.SearchHit;<br>import org.elasticsearch.search.SearchHits;<br>import org.elasticsearch.search.aggregations.AggregationBuilders;<br>import org.elasticsearch.search.builder.SearchSourceBuilder;<br>import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;<br>import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;<br>import org.elasticsearch.search.sort.SortOrder;</p>
</blockquote>
<p>import java.util.Map;</p>
<p>public class QueryDoc &#123;</p>
<pre><code>public static final ElasticsearchTask SEARCH_WITH_MAX = client -&amp;gt; &#123;
    // 高亮查询
    SearchRequest request = new SearchRequest().indices(&quot;user&quot;);
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    sourceBuilder.aggregation(AggregationBuilders.max(&quot;maxAge&quot;).field(&quot;age&quot;));
    //设置请求体
    request.source(sourceBuilder);
    //3.客户端发送请求，获取响应对象
    SearchResponse response = client.search(request, RequestOptions.DEFAULT);
    //4.打印响应结果
    SearchHits hits = response.getHits();
    System.out.println(response);
&#125;;

public static void main(String[] args) &#123;
    ConnectElasticsearch.connect(SEARCH_WITH_MAX);
&#125;
</code></pre>
<p>}<br></code></pre><br> 后台打印<br> <pre><code>&#123;"took":16,"timed_out":false,"_shards":&#123;"total":1,"successful":1,"skipped":0,"failed":0&#125;,"hits":&#123;"total":&#123;"value":6,"relation":"eq"&#125;,"max_score":1.0,"hits":[&#123;"_index":"user","_type":"_doc","_id":"1001","_score":1.0,"_source":&#123;"name":"zhangsan","age":"10","sex":"女"&#125;&#125;,&#123;"_index":"user","_type":"_doc","_id":"1002","_score":1.0,"_source":&#123;"name":"lisi","age":"30","sex":"女"&#125;&#125;,&#123;"_index":"user","_type":"_doc","_id":"1003","_score":1.0,"_source":&#123;"name":"wangwu1","age":"40","sex":"男"&#125;&#125;,&#123;"_index":"user","_type":"_doc","_id":"1004","_score":1.0,"_source":&#123;"name":"wangwu2","age":"20","sex":"女"&#125;&#125;,&#123;"_index":"user","_type":"_doc","_id":"1005","_score":1.0,"_source":&#123;"name":"wangwu3","age":"50","sex":"男"&#125;&#125;,&#123;"_index":"user","_type":"_doc","_id":"1006","_score":1.0,"_source":&#123;"name":"wangwu4","age":"20","sex":"男"&#125;&#125;]&#125;,"aggregations":&#123;"max#maxAge":&#123;"value":50.0&#125;&#125;&#125;</p>
<p>Process finished with exit code 0<br></code></pre><br> <h3>分组查询</h3><br> <pre><code class="language-java">import com.lun.elasticsearch.hello.ConnectElasticsearch;<br>import com.lun.elasticsearch.hello.ElasticsearchTask;<br>import org.elasticsearch.action.search.SearchRequest;<br>import org.elasticsearch.action.search.SearchResponse;<br>import org.elasticsearch.client.RequestOptions;<br>import org.elasticsearch.common.unit.Fuzziness;<br>import org.elasticsearch.index.query.BoolQueryBuilder;<br>import org.elasticsearch.index.query.QueryBuilders;<br>import org.elasticsearch.index.query.RangeQueryBuilder;<br>import org.elasticsearch.index.query.TermsQueryBuilder;<br>import org.elasticsearch.search.SearchHit;<br>import org.elasticsearch.search.SearchHits;<br>import org.elasticsearch.search.aggregations.AggregationBuilders;<br>import org.elasticsearch.search.builder.SearchSourceBuilder;<br>import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;<br>import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;<br>import org.elasticsearch.search.sort.SortOrder;</p>
<p>import java.util.Map;</p>
<p>public class QueryDoc &#123;</p>
<pre><code>public static final ElasticsearchTask SEARCH_WITH_GROUP = client -&amp;gt; &#123;
    SearchRequest request = new SearchRequest().indices(&quot;user&quot;);
    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
    sourceBuilder.aggregation(AggregationBuilders.terms(&quot;age_groupby&quot;).field(&quot;age&quot;));
    //设置请求体
    request.source(sourceBuilder);
    //3.客户端发送请求，获取响应对象
    SearchResponse response = client.search(request, RequestOptions.DEFAULT);
    //4.打印响应结果
    SearchHits hits = response.getHits();
    System.out.println(response);
&#125;;

public static void main(String[] args) &#123;
    ConnectElasticsearch.connect(SEARCH_WITH_GROUP);
&#125;
</code></pre>
<p>}<br></code></pre><br> 后台打印<br> <pre><code class="language-java">&#123;"took":10,"timed_out":false,"_shards":&#123;"total":1,"successful":1,"skipped":0,"failed":0&#125;,"hits":&#123;"total":&#123;"value":6,"relation":"eq"&#125;,"max_score":1.0,"hits":[&#123;"_index":"user","_type":"_doc","_id":"1001","_score":1.0,"_source":&#123;"name":"zhangsan","age":"10","sex":"女"&#125;&#125;,&#123;"_index":"user","_type":"_doc","_id":"1002","_score":1.0,"_source":&#123;"name":"lisi","age":"30","sex":"女"&#125;&#125;,&#123;"_index":"user","_type":"_doc","_id":"1003","_score":1.0,"_source":&#123;"name":"wangwu1","age":"40","sex":"男"&#125;&#125;,&#123;"_index":"user","_type":"_doc","_id":"1004","_score":1.0,"_source":&#123;"name":"wangwu2","age":"20","sex":"女"&#125;&#125;,&#123;"_index":"user","_type":"_doc","_id":"1005","_score":1.0,"_source":&#123;"name":"wangwu3","age":"50","sex":"男"&#125;&#125;,&#123;"_index":"user","_type":"_doc","_id":"1006","_score":1.0,"_source":&#123;"name":"wangwu4","age":"20","sex":"男"&#125;&#125;]&#125;,"aggregations":&#123;"lterms#age_groupby":&#123;"doc_count_error_upper_bound":0,"sum_other_doc_count":0,"buckets":[&#123;"key":20,"doc_count":2&#125;,&#123;"key":10,"doc_count":1&#125;,&#123;"key":30,"doc_count":1&#125;,&#123;"key":40,"doc_count":1&#125;,&#123;"key":50,"doc_count":1&#125;]&#125;&#125;&#125;</p>
<p>Process finished with exit code 0<br></code></pre> 
   </p>
<p> </p>
<p> </p>
<p> </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Elasticsearch之analysis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/18/Elasticsearch%E4%B9%8Banalysis/"
    >Elasticsearch之analysis</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/07/18/Elasticsearch%E4%B9%8Banalysis/" class="article-date">
  <time datetime="2021-07-18T14:21:56.442Z" itemprop="datePublished">2021-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Elasticsearch/">Elasticsearch</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>title: Elasticsearch之analysis<br>categories:</p>
<ul>
<li>elasticsearch</li>
</ul>
<p>—### 1、简介</p>
<blockquote>
<p> analysis(只是一个概念)，文本分析是将全文本转换为一系列单词的过程，也叫分词。analysis是通 过analyzer(分词器)来实现的，可以使用Elasticsearch内置的分词器，也可以自己去定制一些分词 器。 除了在数据写入的时候进行分词处理，那么在查询的时候也可以使用分析器对查询语句进行分词。<br> anaylzer是由三部分组成，例如有：Hello a World, the world is beautiful </p>
</blockquote>
<ol>
<li>Character Filter: 将文本中html标签剔除掉。 </li>
<li>Tokenizer: 按照规则进行分词，在英文中按照空格分词。 </li>
<li>Token Filter: 去掉stop world(停顿词，a, an, the, is, are等)，然后转换小写 <img alt="" height="201" src="https://img-blog.csdnimg.cn/20210701230820389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="739"> </li>
</ol>
<h3 id="2、内置分词器"><a href="#2、内置分词器" class="headerlink" title="2、内置分词器"></a>2、内置分词器</h3><blockquote>
 <img alt="" height="296" src="https://img-blog.csdnimg.cn/20210701230857488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="740"> 
 内置分词器示例： 
 <img alt="" height="545" src="https://img-blog.csdnimg.cn/20210701231016915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="779"> 
 <img alt="" height="557" src="https://img-blog.csdnimg.cn/20210701231031310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="796"> 
</blockquote>
<h3 id="3、ik分词器"><a href="#3、ik分词器" class="headerlink" title="3、ik分词器"></a>3、ik分词器</h3><blockquote>
<p> IK分词器在任何操作系统下安装步骤均⼀样: 在ES的家⽬录下的 plugins ⽬录下创建名为 ik 的 ⽂件夹，然后将下载后的 zip 包拷⻉到 ik 解压即可<br> IK分词器提供了两种分词⽅式：<br> <img alt="" height="271" src="https://img-blog.csdnimg.cn/20210704114331635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="991"><br> 验证：<br> <img alt="" height="280" src="https://img-blog.csdnimg.cn/20210704114423155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1007"><br> <img alt="" height="76" src="https://img-blog.csdnimg.cn/20210704114551497.png" width="483"><img alt="" height="205" src="https://img-blog.csdnimg.cn/20210704114605160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="992"> </p>
</blockquote>
<h3 id="4、⾃定义词库"><a href="#4、⾃定义词库" class="headerlink" title="4、⾃定义词库"></a>4、⾃定义词库</h3><blockquote>
<p> 在很多的时候，业务上的⼀些词库极有可能不在IK分词器的词库中，需要去定制属于我们⾃⼰的词 库。例如下⾯的例⼦中， 正井猫 、 up主 被切分为⼀个个的字，我们希望这两个词语是不被拆 分；另外 的 作为中⽂的停顿词，也不希望出现在分词中，所以我们需要⾃定义词库和停顿词词 库。<br> <img alt="" height="166" src="https://img-blog.csdnimg.cn/20210704115725621.png" width="988"><img alt="" height="798" src="https://img-blog.csdnimg.cn/20210704115746521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"><br> 进⼊到 $ES_HOME/plugins/ik/config ⽬录下，创建 custom ⽬录，在⽬录下创建 mydic.dic 、 ext_stopword.dic ⽂件，<br> 在 mydic.dic ⽂件中添加两⾏内容：<br> <img alt="" height="101" src="https://img-blog.csdnimg.cn/20210704121115600.png" width="620"> 在 ext_stopword.dic 中添加⼀⾏内容:<br> <img alt="" height="61" src="https://img-blog.csdnimg.cn/20210704121136941.png" width="485"><br> 最后修改 $ES_HOME/plugins/ik/config/IKAnalyzer.cfg.xml ⽂件，内容如下：<br> <img alt="" height="501" src="https://img-blog.csdnimg.cn/2021070412115725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1102"><br> 重启重启elasticsearch elasticsearch ， 重新执⾏如上的命令，结果如下：<br> <img alt="" height="579" src="https://img-blog.csdnimg.cn/20210704121221247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> </p>
</blockquote>
<h3 id="5、IK分词器在工作中的实际案例"><a href="#5、IK分词器在工作中的实际案例" class="headerlink" title="5、IK分词器在工作中的实际案例"></a>5、IK分词器在工作中的实际案例</h3><blockquote>
<p> 5.1、首先创建new索引的mapping<br> <pre><code class="language-javascript">PUT news<br>&#123;<br>  "mappings": &#123;<br>    "properties": &#123;<br>      "title":&#123;<br>        "type": "text",<br>        "analyzer": "ik_max_word",<br>        "search_analyzer": "ik_smart"<br>      &#125;,<br>      "content":&#123;<br>        "type": "text",<br>        "analyzer": "ik_max_word",<br>        "search_analyzer": "ik_smart"<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;</code></pre><br> 注意：analyzer和search_analyzer的区别如下：<br>       analyzer：表示数据在进入news这个索引中的时候，我们尽量让它多的对我们数据进行分词，后面才能够达到精准的匹配。<br>       search_analyzer：对我们的数据进行搜索的时候不要进行过多的分词处理，提高效率。<br> 5.2、查看创建的索引结构<br>      GET news/_mapping<br>      <img alt="" height="402" src="https://img-blog.csdnimg.cn/20210704123038178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="520"><br> 5.3、创建数据进入索引<br> <img alt="" height="438" src="https://img-blog.csdnimg.cn/20210704123835184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="854"><br> 5.4、通过语句查询<br> <img alt="" height="234" src="https://img-blog.csdnimg.cn/20210704124000129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="659"><br> <img alt="" height="758" src="https://img-blog.csdnimg.cn/20210704124016440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1157"><br> 下面我们再新增两条数据测试<br> <img alt="" height="212" src="https://img-blog.csdnimg.cn/2021070412571235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="638"><br> 查询一下柳岩：<br> <img alt="" height="181" src="https://img-blog.csdnimg.cn/20210704125756473.png" width="660"><br> <img alt="" height="766" src="https://img-blog.csdnimg.cn/20210704125822468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1160"><br> 可以发现我们其实仅仅只是查询柳岩，但是两条数据都查询出来了，那么我们首先配置一下mydic.dic扩展词典：<br> <img alt="" height="212" src="https://img-blog.csdnimg.cn/20210704130118770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="422"><br> 重新启动elasticsearch:<br> 因为我们之前的数据已经分过词了，所以我们需要重新分词相关数据：<br> 先重新索引柳岩：<br> <pre><code class="language-html">POST news/_update_by_query<br>&#123;<br>  "query": &#123;<br>    "bool": &#123;<br>      "should": [<br>        &#123;<br>          "bool": &#123;<br>            "must": [<br>              &#123;<br>                "term": &#123;<br>                  "title": &#123;<br>                    "value": "柳"<br>                  &#125;<br>                &#125;<br>              &#125;,&#123;<br>                "term": &#123;<br>                  "title": &#123;<br>                    "value": "岩"<br>                  &#125;<br>                &#125;<br>              &#125;<br>            ]<br>          &#125;<br>        &#125;,&#123;<br>          "bool": &#123;<br>            "must": [<br>              &#123;<br>                "term": &#123;<br>                  "content": &#123;<br>                    "value": "柳"<br>                  &#125;<br>                &#125;<br>              &#125;,&#123;<br>                "term": &#123;<br>                  "content": &#123;<br>                    "value": "岩"<br>                  &#125;<br>                &#125;<br>              &#125;<br>            ]<br>          &#125;<br>        &#125;<br>      ]<br>    &#125;<br>  &#125;<br>&#125;</code></pre><br> 先重新索引柳真：<br> <pre><code class="language-html">POST news/_update_by_query<br>&#123;<br>  "query": &#123;<br>    "bool": &#123;<br>      "should": [<br>        &#123;<br>          "bool": &#123;<br>            "must": [<br>              &#123;<br>                "term": &#123;<br>                  "title": &#123;<br>                    "value": "柳"<br>                  &#125;<br>                &#125;<br>              &#125;,&#123;<br>                "term": &#123;<br>                  "title": &#123;<br>                    "value": "真"<br>                  &#125;<br>                &#125;<br>              &#125;<br>            ]<br>          &#125;<br>        &#125;,&#123;<br>          "bool": &#123;<br>            "must": [<br>              &#123;<br>                "term": &#123;<br>                  "content": &#123;<br>                    "value": "柳"<br>                  &#125;<br>                &#125;<br>              &#125;,&#123;<br>                "term": &#123;<br>                  "content": &#123;<br>                    "value": "真"<br>                  &#125;<br>                &#125;<br>              &#125;<br>            ]<br>          &#125;<br>        &#125;<br>      ]<br>    &#125;<br>  &#125;<br>&#125;</code></pre><br> 再次查询：<br> <img alt="" height="200" src="https://img-blog.csdnimg.cn/20210704134645260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="579"><br> <img alt="" height="625" src="https://img-blog.csdnimg.cn/20210704134700972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1179"> </p>
</blockquote>
<h3 id="6、pinyin分词器的安装"><a href="#6、pinyin分词器的安装" class="headerlink" title="6、pinyin分词器的安装"></a>6、pinyin分词器的安装</h3><blockquote>
<p> pinyin 分词器在任何操作系统下安装步骤均⼀样: 在ES的家⽬录下的 plugins ⽬录下创建名为 pinyin 的⽂件夹，然后将下载后的 zip 包拷⻉到 pinyin 解压即可<br> <img alt="" height="219" src="https://img-blog.csdnimg.cn/202107041449420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="827"><br> 重启es<br> 测试pingyin插件<br> <img alt="" height="154" src="https://img-blog.csdnimg.cn/20210704145316140.png" width="653"><br> 效果：<br> <img alt="" height="539" src="https://img-blog.csdnimg.cn/2021070414533563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="484"> </p>
</blockquote>
<h3 id="6、Elasticsearch之⾃定义分词器以及应⽤"><a href="#6、Elasticsearch之⾃定义分词器以及应⽤" class="headerlink" title="6、Elasticsearch之⾃定义分词器以及应⽤"></a>6、Elasticsearch之⾃定义分词器以及应⽤</h3><blockquote>
<p> 6.1、案例需求：<br> <img alt="" height="58" src="https://img-blog.csdnimg.cn/20210704154206109.png" width="796"><img alt="" height="783" src="https://img-blog.csdnimg.cn/20210704154226316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="463"><br> 6.2、设置分词器<br> <img alt="" height="621" src="https://img-blog.csdnimg.cn/20210704154308863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="699"><br> 6.3、验证分词器效果<br> <img alt="" height="135" src="https://img-blog.csdnimg.cn/20210704154525604.png" width="800"><br> <img alt="" height="588" src="https://img-blog.csdnimg.cn/20210704154546577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="982"><br> 6.4、为属性添加分词器<br> <img alt="" height="373" src="https://img-blog.csdnimg.cn/20210704154634587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="996"><br> 6.5、结果验证<br>    执⾏如下命令添加数据<br>    <img alt="" height="234" src="https://img-blog.csdnimg.cn/20210704154704254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="452">    <img alt="" height="728" src="https://img-blog.csdnimg.cn/20210704154744408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"><br> <img alt="" height="462" src="https://img-blog.csdnimg.cn/20210704154800679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"><br> <img alt="" height="566" src="https://img-blog.csdnimg.cn/20210704154826224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1200"> </p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Elasticsearch优化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/18/Elasticsearch%E4%BC%98%E5%8C%96/"
    >Elasticsearch优化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/07/18/Elasticsearch%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2021-07-18T14:21:56.440Z" itemprop="datePublished">2021-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Elasticsearch/">Elasticsearch</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>title: Elasticsearch优化<br>categories:</p>
<ul>
<li>elasticsearch</li>
</ul>
<p>—### 1、硬件选择</p>
<blockquote>
<p> Elasticsearch 的基础是 Lucene，所有的索引和文档数据是存储在本地的磁盘中，具体的路径可在 ES 的配置文件…/config/elasticsearch.yml中配置，如下：<br> <pre><code class="language-XML">#</p>
</blockquote>
<h1 id="Path-to-directory-where-to-store-the-data-separate-multiple-locations-by-comma"><a href="#Path-to-directory-where-to-store-the-data-separate-multiple-locations-by-comma" class="headerlink" title="Path to directory where to store the data (separate multiple locations by comma):"></a>Path to directory where to store the data (separate multiple locations by comma):</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>path.data: /path/to/data<br>#</p>
<h1 id="Path-to-log-files"><a href="#Path-to-log-files" class="headerlink" title="Path to log files:"></a>Path to log files:</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><p>path.logs: /path/to/logs<br></code></pre><br> 磁盘在现代服务器上通常都是瓶颈。Elasticsearch重度使用磁盘，你的磁盘能处理的吞吐量越大，你的节点就越稳定。这里有一些优化磁盘I/O的技巧： </p>
<ul>
<li>使用SSD就像其他地方提过的，他们比机械磁盘优秀多了。- 使用RAID0。条带化RAID会提高磁盘IO，代价显然就是当一块硬盘故障时整个就故障了。不要使用镜像或者奇偶校验RAID，因为副本已经提供了这个功能。- 另外，使用多块硬盘，并允许Elasticsearch 通过多个path data目录配置把数据条带化分配到它们上面。- 不要使用远程挂载的存储，比如NFS或者SMB/CIFS。这个引入的延迟对性能来说完全是背道而驰的。</li>
</ul>
<h3 id="2、分片策略"><a href="#2、分片策略" class="headerlink" title="2、分片策略"></a>2、分片策略</h3><blockquote>
 <h3>合理设置分片数</h3> 
 分片和副本的设计为 ES 提供了支持分布式和故障转移的特性，但并不意味着分片和副本是可以无限分配的。而且索引的分片完成分配后由于索引的路由机制，我们是不能重新修改分片数的。 
 可能有人会说，我不知道这个索引将来会变得多大，并且过后我也不能更改索引的大小，所以为了保险起见，还是给它设为 1000 个分片吧。但是需要知道的是，一个分片并不是没有代价的。需要了解： 
</blockquote>
<ul>
<li>一个分片的底层即为一个 Lucene 索引，会消耗一定文件句柄、内存、以及 CPU运转。- 每一个搜索请求都需要命中索引中的每一个分片，如果每一个分片都处于不同的节点还好， 但如果多个分片都需要在同一个节点上竞争使用相同的资源就有些糟糕了。- 用于计算相关度的词项统计信息是基于分片的。如果有许多分片，每一个都只有很少的数据会导致很低的相关度。<br>一个业务索引具体需要分配多少分片可能需要架构师和技术人员对业务的增长有个预先的判断，横向扩展应当分阶段进行。为下一阶段准备好足够的资源。 只有当你进入到下一个阶段，你才有时间思考需要作出哪些改变来达到这个阶段。一般来说，我们遵循一些原则： </li>
<li>控制每个分片占用的硬盘容量不超过 ES 的最大 JVM 的堆空间设置（一般设置不超过 32G，参考下文的 JVM 设置原则），因此，如果索引的总容量在 500G 左右，那分片大小在 16 个左右即可；当然，最好同时考虑原则 2。- 考虑一下 node 数量，一般一个节点有时候就是一台物理机，如果分片数过多，大大超过了节点数，很可能会导致一个节点上存在多个分片，一旦该节点故障，即使保持了 1 个以上的副本，同样有可能会导致数据丢失，集群无法恢复。所以， 一般都设置分片数不超过节点数的 3 倍。- 主分片，副本和节点最大数之间数量，我们分配的时候可以参考以下关系：- 节点数&lt;=主分片数 *（副本数+1）</li>
</ul>
<h3 id="3、推迟分片分配"><a href="#3、推迟分片分配" class="headerlink" title="3、推迟分片分配"></a>3、推迟分片分配</h3><blockquote>
<p> 对于节点瞬时中断的问题，默认情况，集群会等待一分钟来查看节点是否会重新加入，如果这个节点在此期间重新加入，重新加入的节点会保持其现有的分片数据，不会触发新的分片分配。这样就可以减少 ES 在自动再平衡可用分片时所带来的极大开销。<br> 通过修改参数 delayed_timeout ，可以延长再均衡的时间，可以全局设置也可以在索引级别进行修改：<br> <pre><code class="language-java">#PUT /_all/_settings<br>&#123;<br>    "settings": &#123;<br>        "index.unassigned.node_left.delayed_timeout": "5m"<br>    &#125;<br>&#125;<br></code></pre> </p>
</blockquote>
<h3 id="4、路由选择"><a href="#4、路由选择" class="headerlink" title="4、路由选择"></a>4、路由选择</h3><blockquote>
<p> 当我们查询文档的时候， Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？它其实是通过下面这个公式来计算出来：<br> <pre><code class="language-java">shard = hash(routing) % number_of_primary_shards<br></code></pre><br> routing 默认值是文档的 id，也可以采用自定义值，比如用户 id。<br> <h3>不带routing查询</h3><br> 在查询的时候因为不知道要查询的数据具体在哪个分片上，所以整个过程分为2个步骤 </p>
</blockquote>
<ul>
<li>分发：请求到达协调节点后，协调节点将查询请求分发到每个分片上。- 聚合：协调节点搜集到每个分片上查询结果，在将查询的结果进行排序，之后给用户返回结果。<h3>带routing查询</h3> 
查询的时候，可以直接根据routing 信息定位到某个分配查询，不需要查询所有的分配，经过协调节点排序。向上面自定义的用户查询，如果routing 设置为userid 的话，就可以直接查询出数据来，效率提升很多。 </li>
</ul>
<h3 id="带routing查询"><a href="#带routing查询" class="headerlink" title="带routing查询"></a>带routing查询</h3><h3 id="5、写入速度优化"><a href="#5、写入速度优化" class="headerlink" title="5、写入速度优化"></a>5、写入速度优化</h3><blockquote>
<p> ES 的默认配置，是综合了数据可靠性、写入速度、搜索实时性等因素。实际使用时，我们需要根据公司要求，进行偏向性的优化。<br> 针对于搜索性能要求不高，但是对写入要求较高的场景，我们需要尽可能的选择恰当写优化策略。综合来说，可以考虑以下几个方面来提升写索引的性能： </p>
</blockquote>
<ul>
<li>加大Translog Flush，目的是降低Iops、Writeblock。- 增加Index Refesh间隔，目的是减少Segment Merge的次数。- 调整Bulk 线程池和队列。- 优化节点间的任务分布。- 优化Lucene层的索引建立，目的是降低CPU及IO。<h3>优化存储设备</h3> 
ES 是一种密集使用磁盘的应用，在段合并的时候会频繁操作磁盘，所以对磁盘要求较高，当磁盘速度提升之后，集群的整体性能会大幅度提高。 
<h3>合理使用合并</h3> 
Lucene 以段的形式存储数据。当有新的数据写入索引时， Lucene 就会自动创建一个新的段。 
随着数据量的变化，段的数量会越来越多，消耗的多文件句柄数及 CPU 就越多，查询效率就会下降。 
由于 Lucene 段合并的计算量庞大，会消耗大量的 I/O，所以 ES 默认采用较保守的策略，让后台定期进行段合并。 
<h3>减少 Refresh 的次数</h3> 
Lucene 在新增数据时，采用了延迟写入的策略，默认情况下索引的refresh_interval 为1 秒。 
Lucene 将待写入的数据先写到内存中，超过 1 秒（默认）时就会触发一次 Refresh，然后 Refresh 会把内存中的的数据刷新到操作系统的文件缓存系统中。 
如果我们对搜索的实效性要求不高，可以将 Refresh 周期延长，例如 30 秒。 
这样还可以有效地减少段刷新次数，但这同时意味着需要消耗更多的 Heap 内存。 
<h3>加大 Flush 设置</h3> 
Flush 的主要目的是把文件缓存系统中的段持久化到硬盘，当 Translog 的数据量达到 512MB 或者 30 分钟时，会触发一次 Flush。 
index.translog.flush_threshold_size 参数的默认值是 512MB，我们进行修改。 
增加参数值意味着文件缓存系统中可能需要存储更多的数据，所以我们需要为操作系统的文件缓存系统留下足够的空间。 
<h3>减少副本的数量</h3> 
ES 为了保证集群的可用性，提供了 Replicas（副本）支持，然而每个副本也会执行分析、索引及可能的合并过程，所以 Replicas 的数量会严重影响写索引的效率。 
当写索引时，需要把写入的数据都同步到副本节点，副本节点越多，写索引的效率就越慢。 
如果我们需要大批量进行写入操作，可以先禁止Replica复制，设置 index.number_of_replicas: 0 关闭副本。在写入完成后， Replica 修改回正常的状态。 </li>
</ul>
<h3 id="合理使用合并"><a href="#合理使用合并" class="headerlink" title="合理使用合并"></a>合理使用合并</h3><h3 id="加大-Flush-设置"><a href="#加大-Flush-设置" class="headerlink" title="加大 Flush 设置"></a>加大 Flush 设置</h3><h3 id="6、内存设置"><a href="#6、内存设置" class="headerlink" title="6、内存设置"></a>6、内存设置</h3><blockquote>
<p> ES 默认安装后设置的内存是 1GB，对于任何一个现实业务来说，这个设置都太小了。如果是通过解压安装的 ES，则在 ES 安装文件中包含一个 jvm.option 文件，添加如下命令来设置 ES 的堆大小， Xms 表示堆的初始大小， Xmx 表示可分配的最大内存，都是 1GB。<br> 确保 Xmx 和 Xms 的大小是相同的，其目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源，可以减轻伸缩堆大小带来的压力。<br> 假设你有一个 64G 内存的机器，按照正常思维思考，你可能会认为把 64G 内存都给ES 比较好，但现实是这样吗， 越大越好？虽然内存对 ES 来说是非常重要的，但是答案是否定的！<br> 因为 ES 堆内存的分配需要满足以下两个原则： </p>
</blockquote>
<ul>
<li>不要超过物理内存的 50%： Lucene 的设计目的是把底层 OS 里的数据缓存到内存中。Lucene 的段是分别存储到单个文件中的，这些文件都是不会变化的，所以很利于缓存，同时操作系统也会把这些段文件缓存起来，以便更快的访问。如果我们设置的堆内存过大， Lucene 可用的内存将会减少，就会严重影响降低 Lucene 的全文本查询性能。- 堆内存的大小最好不要超过 32GB：在 Java 中，所有对象都分配在堆上，然后有一个 Klass Pointer 指针指向它的类元数据。这个指针在 64 位的操作系统上为 64 位， 64 位的操作系统可以使用更多的内存（2^64）。在 32 位的系统上为 32 位， 32 位的操作系统的最大寻址空间为 4GB（2^32）。但是 64 位的指针意味着更大的浪费，因为你的指针本身大了。浪费内存不算，更糟糕的是，更大的指针在主内存和缓存器（例如 LLC, L1 等）之间移动数据的时候，会占用更多的带宽。<br>最终我们都会采用 31 G 设置 </li>
<li>-Xms 31g- -Xmx 31g<br>假设你有个机器有 128 GB 的内存，你可以创建两个节点，每个节点内存分配不超过 32 GB。也就是说不超过 64 GB 内存给 ES 的堆内存，剩下的超过 64 GB 的内存给 Lucene。 </li>
</ul>
<h3 id="7、重要配置"><a href="#7、重要配置" class="headerlink" title="7、重要配置"></a>7、重要配置</h3><blockquote>
 <h3> <img alt="" height="732" src="https://img-blog.csdnimg.cn/20210626214501178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tfNTIwX1c=,size_16,color_FFFFFF,t_70" width="1196"></h3> 
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Elasticsearch相关问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/18/Elasticsearch%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"
    >Elasticsearch相关问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/07/18/Elasticsearch%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2021-07-18T14:21:56.438Z" itemprop="datePublished">2021-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Elasticsearch/">Elasticsearch</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>title: Elasticsearch相关问题<br>categories:</p>
<ul>
<li>elasticsearch</li>
</ul>
<p>—### 1、为什么要使用 Elasticsearch？</p>
<blockquote>
<p> 系统中的数据， 随着业务的发展，时间的推移， 将会非常多， 而业务中往往采用模糊查询进行数据的搜索， 而模糊查询会导致查询引擎放弃索引，导致系统查询数据时都是全表扫描，在百万级别的数据库中，查询效率是非常低下的，而我们使用 ES 做一个全文索引，将经常查询的系统功能的某些字段，比如说电商系统的商品表中商品名，描述、价格还有 id 这些字段我们放入 ES 索引库里，可以提高查询速度。 </p>
</blockquote>
<h3 id="2、Elasticsearch-的-master-选举流程？"><a href="#2、Elasticsearch-的-master-选举流程？" class="headerlink" title="2、Elasticsearch 的 master 选举流程？"></a>2、Elasticsearch 的 master 选举流程？</h3><blockquote>
</blockquote>
<ul>
<li>Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含-一个主机列表以控制哪些节点需要ping通）这两部分。- 对所有可以成为master的节点（node master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。- 如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。- master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能。</li>
</ul>
<h3 id="3、Elasticsearch-集群脑裂问题？"><a href="#3、Elasticsearch-集群脑裂问题？" class="headerlink" title="3、Elasticsearch 集群脑裂问题？"></a>3、Elasticsearch 集群脑裂问题？</h3><blockquote>
<p> “脑裂”问题可能的成因： </p>
</blockquote>
<ul>
<li>网络问题：集群间的网络延迟导致一些节点访问不到master, 认为master 挂掉了从而选举出新的master,并对master上的分片和副本标红，分配新的主分片。- 节点负载：主节点的角色既为master又为data,访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。- 内存回收：data 节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。<br>脑裂问题解决方案： </li>
<li>减少误判：discovery.zen ping_ timeout 节点状态的响应时间，默认为3s，可以适当调大，如果master在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如6s，discovery.zen.ping_timeout:6），可适当减少误判。- 选举触发：discovery.zen.minimum. <em>master</em> nodes:1，该参數是用于控制选举行为发生的最小集群主节点数量。当备选主节点的个數大于等于该参数的值，且备选主节点中有该参数个节点认为主节点挂了，进行选举。官方建议为(n / 2) +1, n为主节点个数（即有资格成为主节点的节点个数）。- 角色分离：即master节点与data节点分离，限制角色 主节点配置为：node master: true，node data: false 从节点配置为：node master: false，node data: true</li>
</ul>
<h3 id="4、Elasticsearch-索引文档的流程？"><a href="#4、Elasticsearch-索引文档的流程？" class="headerlink" title="4、Elasticsearch 索引文档的流程？"></a>4、Elasticsearch 索引文档的流程？</h3><blockquote>
 <img alt="" src="https://img-blog.csdnimg.cn/img_convert/1bdc6c30d1be9b1bff83a683c64d2ac7.png"> 
</blockquote>
<ul>
<li>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合适的分片：shard = hash(document_id) % (num_of_primary_shards)- 当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory Buffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 Memory Buffer 到 Filesystem Cache 的过程就叫做 refresh；- 当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失， ES 是通过 translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystemcache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；- 在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync 将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。- flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；</li>
</ul>
<h3 id="5、Elasticsearch-更新和删除文档的流程？"><a href="#5、Elasticsearch-更新和删除文档的流程？" class="headerlink" title="5、Elasticsearch 更新和删除文档的流程？"></a>5、Elasticsearch 更新和删除文档的流程？</h3><blockquote>
</blockquote>
<ul>
<li>删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；- 磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入新段。- 在新的文档被创建时， Elasticsearch 会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</li>
</ul>
<h3 id="6、Elasticsearch-搜索的流程？"><a href="#6、Elasticsearch-搜索的流程？" class="headerlink" title="6、Elasticsearch 搜索的流程？"></a>6、Elasticsearch 搜索的流程？</h3><blockquote>
 <img alt="" src="https://img-blog.csdnimg.cn/img_convert/053a14eee04ace7b4e5aec0ce53a5284.png"> 
</blockquote>
<ul>
<li>搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；- 在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。 PS：在搜索的时候是会查询Filesystem Cache 的，但是有部分数据还在 Memory Buffer，所以搜索是近实时的。- 每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。- 接下来就是取回阶段， 协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。- Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确， DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差。</li>
</ul>
<h3 id="7、Elasticsearch-在部署时，对-Linux-的设置有哪些优化方法？"><a href="#7、Elasticsearch-在部署时，对-Linux-的设置有哪些优化方法？" class="headerlink" title="7、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？"></a>7、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？</h3><blockquote>
</blockquote>
<ul>
<li>64 GB 内存的机器是非常理想的， 但是 32 GB 和 16 GB 机器也是很常见的。少于 8 GB 会适得其反。- 如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。- 如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起， SSD 是一个好的选择。- 即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。- 请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用 Java 的本地序列化。- 通过设置 gateway.recover_after_nodes、 gateway.expected_nodes、 gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。- Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。- 不要随意修改垃圾回收器（CMS）和各个线程池的大小。- 把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过 ES_HEAP_SIZE 环境变量设置。- 内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个 100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。- Lucene 使用了大量的文件。同时， Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如 64,000。</li>
</ul>
<h3 id="8、GC-方面，在使用-Elasticsearch-时要注意什么？"><a href="#8、GC-方面，在使用-Elasticsearch-时要注意什么？" class="headerlink" title="8、GC 方面，在使用 Elasticsearch 时要注意什么？"></a>8、GC 方面，在使用 Elasticsearch 时要注意什么？</h3><blockquote>
<p> 倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segment memory 增长趋势。<br> 各类缓存， field cache, filter cache, indexing cache, bulk queue 等等，要设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache 等“自欺欺人”的方式来释放内存。<br> 避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用 scan &amp; scroll api 来实现。<br> cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过 tribe node 连接。<br> 想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做持续的监控。 </p>
</blockquote>
<h3 id="9、Elasticsearch-对于大数据量（上亿量级）的聚合如何实现？"><a href="#9、Elasticsearch-对于大数据量（上亿量级）的聚合如何实现？" class="headerlink" title="9、Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？"></a>9、Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？</h3><blockquote>
<p> Elasticsearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，即该字段的 distinct或者 unique 值的数目。它是基于 HLL 算法的。 HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。 </p>
</blockquote>
<h3 id="10、在并发情况下，-Elasticsearch-如果保证读写一致？"><a href="#10、在并发情况下，-Elasticsearch-如果保证读写一致？" class="headerlink" title="10、在并发情况下， Elasticsearch 如果保证读写一致？"></a>10、在并发情况下， Elasticsearch 如果保证读写一致？</h3><blockquote>
</blockquote>
<ul>
<li>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；- 另外对于写操作，一致性级别支持 quorum/one/all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。- 对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。</li>
</ul>
<h3 id="11、如何监控-Elasticsearch-集群状态？"><a href="#11、如何监控-Elasticsearch-集群状态？" class="headerlink" title="11、如何监控 Elasticsearch 集群状态？"></a>11、如何监控 Elasticsearch 集群状态？</h3><blockquote>
</blockquote>
<ul>
<li>elasticsearch-head 插件。- 通过 Kibana 监控 Elasticsearch。你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标</li>
</ul>
<h3 id="12、Elasticsearch-中的集群、节点、索引、文档、类型是什么？"><a href="#12、Elasticsearch-中的集群、节点、索引、文档、类型是什么？" class="headerlink" title="12、Elasticsearch 中的集群、节点、索引、文档、类型是什么？"></a>12、Elasticsearch 中的集群、节点、索引、文档、类型是什么？</h3><blockquote>
</blockquote>
<ul>
<li>集群是一个或多个节点（服务器）的集合，它们共同保存您的整个数据，并提供跨所有节点的联合索引和搜索功能。群集由唯一名 称标识，默认情况下为”elasticsearch”。此名称很重要，因为如果节点设置为按名称加入群集，则该节点只能是群集的一部分。- 节点是属于集群一部分的单个服务器。它存储数据并参与群集索引和搜索功能。- 索引就像关系数据库中的“数据库”。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个或多个主分片，并且可以有零个或多个副本分片。MySQL =&gt;数据库，Elasticsearch=&gt;索引。- 文档类似于关系数据库中的一行。不同之处在于索引中的每个文档可以具有不同的结构(字段)，但是对于通用字段应该具有相同的数据类型。MySQL =&gt; Databases =&gt; Tables =&gt; Columns / Rows，Elasticsearch=&gt; Indices =&gt; Types =&gt;具有属性的文档Doc。- 类型是索引的逻辑类别/分区，其语义完全取决于用户。</li>
</ul>
<h3 id="13、Elasticsearch-中的倒排索引是什么？"><a href="#13、Elasticsearch-中的倒排索引是什么？" class="headerlink" title="13、Elasticsearch 中的倒排索引是什么？"></a>13、Elasticsearch 中的倒排索引是什么？</h3><blockquote>
<p> 倒排索引是搜索引擎的核心。搜索引擎的主要目标是在查找发生搜索条件的文档时提供快速搜索。ES中的倒排索引其实就是 lucene 的倒排索引，区别于传统的正向索引， 倒排索引会再存储数据时将关键词和数据进行关联，保存到倒排表中，然后查询时，将查询内容进行分词后在倒排表中进行查询，最后匹配数据即可。 </p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Elasticsearch相关核心概念"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/18/Elasticsearch%E7%9B%B8%E5%85%B3%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"
    >Elasticsearch相关核心概念</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/07/18/Elasticsearch%E7%9B%B8%E5%85%B3%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2021-07-18T14:21:56.436Z" itemprop="datePublished">2021-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Elasticsearch/">Elasticsearch</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>title: Elasticsearch相关核心概念<br>categories:</p>
<ul>
<li>elasticsearch</li>
</ul>
<p>—<img alt="" src="https://img-blog.csdnimg.cn/img_convert/146a779da01f53e7f7a8d53132d3c7cf.png"></p>
<h3 id="1、索引Index"><a href="#1、索引Index" class="headerlink" title="1、索引Index"></a>1、索引Index</h3><blockquote>
<p>         一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除（CRUD）的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。<br>         能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。<br>      <strong>Elasticsearch 索引的精髓：一切设计都是为了提高搜索的性能。</strong> </p>
</blockquote>
<h3 id="2、-类型Type"><a href="#2、-类型Type" class="headerlink" title="2、 类型Type"></a>2、 类型Type</h3><blockquote>
<p> 在一个索引中，你可以定义一种或多种类型。<br> 一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。不同的版本，类型发生了不同的变化。<br> <table><thead>|版本|Type</p>
</blockquote>
</thead><tbody>|5.x|支持多种 type
|6.x|只能有一种 type
|7.x|默认不再支持自定义索引类型（默认类型为： _doc）
</tbody></table>


<h3 id="3、文档Document"><a href="#3、文档Document" class="headerlink" title="3、文档Document"></a>3、文档Document</h3><blockquote>
<p> 一个文档是一个可被索引的基础信息单元，也就是一条数据。<br> 比如：你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以 JSON（Javascript Object Notation）格式来表示，而 JSON 是一个到处存在的互联网数据交互格式。<br> 在一个 index/type 里面，你可以存储任意多的文档。 </p>
</blockquote>
<h3 id="4、字段Field"><a href="#4、字段Field" class="headerlink" title="4、字段Field"></a>4、字段Field</h3><blockquote>
<p> 相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。 </p>
</blockquote>
<h3 id="5、映射Mapping"><a href="#5、映射Mapping" class="headerlink" title="5、映射Mapping"></a>5、映射Mapping</h3><blockquote>
<p> mapping 是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理 ES 里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。 </p>
</blockquote>
<h3 id="6、分片Shards"><a href="#6、分片Shards" class="headerlink" title="6、分片Shards"></a>6、分片Shards</h3><blockquote>
<p> 一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有 10 亿文档数据<br> 的索引占据 1TB 的磁盘空间，而任一节点都可能没有这样大的磁盘空间。 或者单个节点处理搜索请求，响应太慢。为了解决这个问题，<strong>Elasticsearch 提供了将索引划分成多份的能力，每一份就称之为分片。</strong>当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。<br> 分片很重要，主要有两方面的原因： </p>
</blockquote>
<ul>
<li>允许你水平分割 / 扩展你的内容容量。- 允许你在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量。<br>至于一个分片怎样分布，它的文档怎样聚合和搜索请求，是完全由 Elasticsearch 管理的，对于作为用户的你来说，这些都是透明的，无需过分关心。<br>被混淆的概念是，一个 Lucene 索引 我们在 Elasticsearch 称作 分片 。 一个Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片（Lucene 索引），然后合并每个分片的结果到一个全局的结果集。<br>Lucene 是 Apache 软件基金会 Jakarta 项目组的一个子项目，提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言， Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。但 Lucene 只是一个提供全文搜索功能类库的核心工具包，而真正使用它还需要一个完善的服务框架搭建起来进行应用。<br>目前市面上流行的搜索引擎软件，主流的就两款： Elasticsearch 和 Solr,这两款都是基于 Lucene 搭建的，可以独立部署启动的搜索引擎服务软件。由于内核相同，所以两者除了服务器安装、部署、管理、集群以外，对于数据的操作 修改、添加、保存、查询等等都十分类似。 </li>
</ul>
<h3 id="7、副本Replicas"><a href="#7、副本Replicas" class="headerlink" title="7、副本Replicas"></a>7、副本Replicas</h3><blockquote>
<p> 在一个网络 / 云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于 离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的， Elasticsearch 允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片(副本)。<br> 复制分片之所以重要，有两个主要原因： </p>
</blockquote>
<ul>
<li>在分片/节点失败的情况下，<strong>提供了高可用性</strong>。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。- 扩展你的搜索量/吞吐量，因为搜索可以在所有的副本上并行运行<br>总之，每个索引可以被分成多个分片。一个索引也可以被复制 0 次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。<br>分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。<br>默认情况下，Elasticsearch 中的每个索引被分片 1 个主分片和 1 个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有 1 个主分片和另外 1 个复制分片（1 个完全拷贝），这样的话每个索引总共就有 2 个分片， 我们需要根据索引需要确定分片个数。 </li>
</ul>
<h3 id="8、分配Allocation"><a href="#8、分配Allocation" class="headerlink" title="8、分配Allocation"></a>8、分配Allocation</h3><blockquote>
<p> 将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程是由 master 节点完成的。 </p>
</blockquote>
<h3 id="9、es的系统架构"><a href="#9、es的系统架构" class="headerlink" title="9、es的系统架构"></a>9、es的系统架构</h3><blockquote>
 <img alt="" src="https://img-blog.csdnimg.cn/img_convert/e4d13427545dc174eb9ccface85c1f0c.png"> 
 一个运行中的 Elasticsearch 实例称为一个节点，而集群是由一个或者多个拥有相同 cluster.name 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。 
 当一个节点被选举成为主节点时， 它将负责管理集群范围内的所有变更，例如增加、 删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。 
 作为用户，我们可以将请求发送到集群中的任何节点 ，包括主节点。 每个节点都知道 任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的 
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> kgf
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/image1.ico" alt="爱上口袋的天空"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>